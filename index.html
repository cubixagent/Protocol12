<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Execution Engine — Tactical Advisor Edition</title>
  <link rel="manifest" href="./manifest.json">
<style>
:root {
  --bg: #08080a;
  --bg1: #0e0e12;
  --bg2: #141418;
  --bg3: #1c1c22;
  --border: #232330;
  --border2: #2e2e3d;
  --accent: #00ff88;
  --accent2: #00cc6a;
  --accent3: rgba(0,255,136,0.10);
  --accent4: rgba(0,255,136,0.03);
  --text: #e4e4ec;
  --text2: #9a9ab0;
  --text3: #55556a;
  --danger: #ff4757;
  --warn: #ffa502;
  --info: #3b82f6;
  --success: #00ff88;
  --font-mono: 'SF Mono','Fira Code','Cascadia Code','Courier New', monospace;
  --font: 'Inter',-apple-system,'SF Pro Display','Segoe UI',sans-serif;
  --radius: 6px;
  --radius2: 10px;
  --radius3: 14px;
  --transition: 0.22s cubic-bezier(.4,0,.2,1);
  --glow: 0 0 24px rgba(0,255,136,0.18);
  --glow-sm: 0 0 10px rgba(0,255,136,0.22);
  --shadow-card: 0 2px 8px rgba(0,0,0,0.28), 0 1px 3px rgba(0,0,0,0.18);
  --shadow-modal: 0 16px 48px rgba(0,0,0,0.55), 0 4px 16px rgba(0,0,0,0.35);
  --shadow-btn: 0 1px 4px rgba(0,0,0,0.25);
}
.theme-midnight {
  --accent: #4488ff;
  --accent2: #2266dd;
  --accent3: rgba(68,136,255,0.10);
  --accent4: rgba(68,136,255,0.03);
  --glow: 0 0 24px rgba(68,136,255,0.18);
  --glow-sm: 0 0 10px rgba(68,136,255,0.22);
}
.theme-graphite {
  --bg: #0a0a0e;
  --bg1: #101018;
  --bg2: #16161f;
  --bg3: #1e1e2a;
  --border: #28283a;
  --border2: #33334a;
  --accent: #00ddcc;
  --accent2: #00aa99;
  --accent3: rgba(0,221,204,0.10);
  --accent4: rgba(0,221,204,0.03);
  --glow: 0 0 24px rgba(0,221,204,0.18);
  --glow-sm: 0 0 10px rgba(0,221,204,0.22);
}
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
html { font-size: 14px; scroll-behavior: smooth; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
body {
  background: var(--bg);
  color: var(--text);
  font-family: var(--font);
  min-height: 100vh;
  overflow-x: hidden;
  line-height: 1.6;
  letter-spacing: 0.01em;
}
body.command-mode { box-shadow: inset 0 0 0 2px var(--danger); animation: commandPulse 2.5s ease-in-out infinite; }
@keyframes commandPulse { 0%,100%{box-shadow:inset 0 0 0 2px var(--danger)} 50%{box-shadow:inset 0 0 0 2px #ff7777,0 0 50px rgba(255,59,59,0.2)} }
@keyframes performanceGlow { 0%{box-shadow:none} 50%{box-shadow:inset 0 0 0 1px var(--accent),0 0 60px var(--accent3)} 100%{box-shadow:none} }
body.performance-glow { animation: performanceGlow 2.2s ease; }
::-webkit-scrollbar { width: 5px; height: 5px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: var(--border2); border-radius: 3px; }
::-webkit-scrollbar-thumb:hover { background: var(--accent2); }
::selection { background: var(--accent3); color: var(--accent); }

/* Banners */
#commandBanner { display: none; background: linear-gradient(90deg,rgba(255,71,87,0.04),rgba(255,71,87,0.10),rgba(255,71,87,0.04)); border-bottom: 1px solid rgba(255,71,87,0.25); color: var(--danger); text-align: center; padding: 10px 24px; font-family: var(--font-mono); font-size: 10px; letter-spacing: 3px; text-transform: uppercase; animation: bannerBlink 3.5s ease-in-out infinite; }
@keyframes bannerBlink { 0%,100%{opacity:1} 50%{opacity:0.5} }
#commandBanner.active { display: block; }
#backupBanner { display: none; background: rgba(255,165,2,0.05); border-bottom: 1px solid rgba(255,165,2,0.2); color: var(--warn); text-align: center; padding: 8px 24px; font-size: 10px; letter-spacing: 1.5px; }
#backupBanner.active { display: flex; align-items: center; justify-content: center; gap: 14px; }

/* Header */
#appHeader { position: sticky; top: 0; z-index: 100; background: rgba(8,8,10,0.92); backdrop-filter: blur(24px) saturate(1.4); border-bottom: 1px solid var(--border); padding: 0 28px; display: flex; align-items: center; justify-content: space-between; height: 60px; }
.header-brand { display: flex; flex-direction: column; gap: 2px; }
.brand-name { font-family: var(--font-mono); font-size: 12px; color: var(--accent); letter-spacing: 4px; text-transform: uppercase; font-weight: 700; }
.brand-sub { font-size: 9px; color: var(--text3); letter-spacing: 2.5px; text-transform: uppercase; font-weight: 400; }
.header-mission { display: flex; align-items: center; gap: 20px; }
#missionCountdown { font-family: var(--font-mono); font-size: 10px; padding: 6px 16px; border: 1px solid currentColor; border-radius: 20px; letter-spacing: 1.5px; transition: all 0.35s; font-weight: 500; }
#missionCountdown.tpi-green { color: var(--success); border-color: rgba(0,255,136,0.3); background: rgba(0,255,136,0.04); }
#missionCountdown.tpi-yellow { color: var(--warn); border-color: rgba(255,165,2,0.3); background: rgba(255,165,2,0.04); }
#missionCountdown.tpi-orange { color: #ff7700; border-color: rgba(255,119,0,0.3); background: rgba(255,119,0,0.04); }
#missionCountdown.tpi-red { color: var(--danger); border-color: rgba(255,71,87,0.3); background: rgba(255,71,87,0.04); }
.header-rank { font-family: var(--font-mono); font-size: 10px; color: var(--text3); letter-spacing: 1.5px; }
.header-rank span { color: var(--accent); font-weight: 600; }

/* Nav */
#mainNav { display: flex; gap: 0; padding: 0 28px; background: var(--bg1); border-bottom: 1px solid var(--border); overflow-x: auto; }
.nav-btn { background: none; border: none; color: var(--text3); font-size: 10px; font-family: var(--font-mono); letter-spacing: 2.5px; text-transform: uppercase; padding: 14px 20px; cursor: pointer; border-bottom: 2px solid transparent; transition: all var(--transition); white-space: nowrap; position: relative; font-weight: 500; }
.nav-btn:hover { color: var(--text2); background: rgba(255,255,255,0.015); }
.nav-btn.active { color: var(--accent); border-bottom-color: var(--accent); background: var(--accent4); }
.nav-btn.active::after { content:''; position:absolute; bottom:0; left:20%; right:20%; height:2px; background:var(--accent); filter:blur(4px); }

/* Content */
#appContent { padding: 28px; max-width: 1440px; margin: 0 auto; }
.view { display: none; }
.view.active { display: block; animation: viewFadeIn 0.3s ease; }
@keyframes viewFadeIn { from{opacity:0;transform:translateY(6px)} to{opacity:1;transform:translateY(0)} }

/* Grid */
.grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
.grid-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px; }
.grid-4 { display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 20px; }
.grid-5 { display: grid; grid-template-columns: repeat(5,1fr); gap: 16px; }
@media(max-width:900px){ .grid-2,.grid-3,.grid-4,.grid-5{grid-template-columns:1fr 1fr;} }
@media(max-width:600px){ .grid-2,.grid-3,.grid-4,.grid-5{grid-template-columns:1fr;} #appContent{padding:14px;} #appHeader{padding:0 14px;height:52px;} #mainNav{padding:0 14px;} .nav-btn{padding:12px 14px;font-size:9px;} }

/* Cards */
.card { background: var(--bg1); border: 1px solid var(--border); border-radius: var(--radius2); padding: 24px; transition: all var(--transition); box-shadow: var(--shadow-card); position: relative; overflow: hidden; }
.card:hover { border-color: var(--border2); transform: translateY(-1px); box-shadow: var(--shadow-card), 0 4px 16px rgba(0,0,0,0.15); }
.card-title { font-size: 10px; font-family: var(--font-mono); letter-spacing: 3px; text-transform: uppercase; color: var(--text3); margin-bottom: 20px; display: flex; align-items: center; gap: 10px; font-weight: 500; }
.card-title .dot { width: 5px; height: 5px; border-radius: 50%; background: var(--accent); flex-shrink: 0; box-shadow: 0 0 6px var(--accent); }
.card-accent { border-color: rgba(0,255,136,0.12); }
.card-accent::before { content:''; position:absolute; top:0; left:0; right:0; height:1px; background:linear-gradient(90deg,transparent,var(--accent3),transparent); }

/* Metric Rings */
.metrics-row { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; }
.metric-ring { display: flex; flex-direction: column; align-items: center; gap: 10px; flex: 1; min-width: 100px; position: relative; }
.ring-svg { width: 88px; height: 88px; filter: drop-shadow(0 0 4px rgba(0,255,136,0.08)); }
.ring-track { fill: none; stroke: var(--bg3); stroke-width: 5; }
.ring-fill { fill: none; stroke: var(--accent); stroke-width: 5; stroke-linecap: round; transition: stroke-dashoffset 0.8s cubic-bezier(.4,0,.2,1); transform-origin: center; transform: rotate(-90deg); }
.ring-val { position: absolute; top: 28px; left: 50%; transform: translateX(-50%); font-family: var(--font-mono); font-size: 17px; font-weight: 700; color: var(--accent); }
.ring-label { font-size: 9px; color: var(--text3); letter-spacing: 2.5px; text-transform: uppercase; text-align: center; font-weight: 500; }
.ring-tooltip { position: relative; }
.ring-tooltip:hover .tooltip-text { opacity: 1; pointer-events: auto; transform: translateX(-50%) translateY(-4px); }
.tooltip-text { position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%) translateY(0); background: var(--bg3); border: 1px solid var(--border2); color: var(--text2); font-size: 10px; padding: 8px 12px; border-radius: var(--radius); white-space: nowrap; opacity: 0; pointer-events: none; transition: all var(--transition); z-index: 50; box-shadow: var(--shadow-card); }

/* Fatigue */
.fatigue-bar-wrap { margin-top: 10px; }
.fatigue-label-row { display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 10px; color: var(--text3); }
.fatigue-bar-track { height: 6px; background: var(--bg3); border-radius: 3px; overflow: hidden; }
.fatigue-bar-fill { height: 100%; border-radius: 3px; transition: width 0.6s cubic-bezier(.4,0,.2,1), background-color 0.4s; }

/* Buttons */
.btn { background: none; border: 1px solid var(--border2); color: var(--text2); padding: 8px 18px; border-radius: var(--radius); font-size: 10px; font-family: var(--font-mono); letter-spacing: 1.5px; cursor: pointer; transition: all var(--transition); text-transform: uppercase; font-weight: 500; box-shadow: var(--shadow-btn); user-select: none; }
.btn:hover { border-color: var(--accent); color: var(--accent); background: var(--accent4); transform: translateY(-1px); }
.btn:active { transform: translateY(0) scale(0.97); }
.btn-primary { background: var(--accent); color: #000; border-color: var(--accent); font-weight: 700; }
.btn-primary:hover { background: var(--accent2); border-color: var(--accent2); color: #000; box-shadow: var(--glow-sm); transform: translateY(-1px); }
.btn-primary:active { transform: translateY(0) scale(0.97); }
.btn-danger { border-color: rgba(255,71,87,0.3); color: var(--danger); }
.btn-danger:hover { background: rgba(255,71,87,0.08); border-color: var(--danger); }
.btn-sm { padding: 5px 12px; font-size: 9px; }
.btn-active { border-color: var(--accent); color: var(--accent); background: var(--accent4); }

/* Inputs */
.input-group { margin-bottom: 16px; }
.input-label { font-size: 9px; color: var(--text3); letter-spacing: 2.5px; text-transform: uppercase; display: block; margin-bottom: 6px; font-weight: 500; }
input, select, textarea { width: 100%; background: var(--bg2); border: 1px solid var(--border); color: var(--text); padding: 10px 14px; border-radius: var(--radius); font-size: 12px; font-family: var(--font); transition: all var(--transition); outline: none; }
input:focus, select:focus, textarea:focus { border-color: var(--accent); box-shadow: 0 0 0 3px var(--accent3); }
input::placeholder { color: var(--text3); }
select option { background: var(--bg2); color: var(--text); }
textarea { resize: vertical; min-height: 80px; line-height: 1.7; }

/* Modals */
.modal-overlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.80); z-index: 200; align-items: center; justify-content: center; padding: 20px; backdrop-filter: blur(8px); }
.modal-overlay.active { display: flex; }
.modal { background: var(--bg1); border: 1px solid var(--border2); border-radius: var(--radius3); padding: 32px; max-width: 500px; width: 100%; max-height: 90vh; overflow-y: auto; animation: modalIn 0.25s cubic-bezier(.4,0,.2,1); box-shadow: var(--shadow-modal); }
@keyframes modalIn { from{opacity:0;transform:scale(0.94) translateY(8px)} to{opacity:1;transform:scale(1) translateY(0)} }
.modal-title { font-family: var(--font-mono); font-size: 11px; letter-spacing: 3px; text-transform: uppercase; color: var(--accent); margin-bottom: 24px; display: flex; align-items: center; justify-content: space-between; font-weight: 600; }
.modal-close { background: none; border: none; color: var(--text3); cursor: pointer; font-size: 20px; transition: all var(--transition); width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; }
.modal-close:hover { color: var(--text); background: var(--bg3); }

/* Block Cards */
.block-card { background: var(--bg2); border: 1px solid var(--border); border-left: 3px solid var(--accent); border-radius: var(--radius); padding: 16px 18px; margin-bottom: 12px; transition: all var(--transition); cursor: grab; box-shadow: 0 1px 4px rgba(0,0,0,0.15); }
.block-card:active { cursor: grabbing; opacity: 0.85; transform: scale(0.99); }
.block-card.completed { border-left-color: var(--text3); opacity: 0.55; }
.block-card.running { border-left-color: var(--success); box-shadow: 0 0 16px rgba(0,255,136,0.10), 0 1px 4px rgba(0,0,0,0.15); }
.block-card.paused { border-left-color: var(--warn); }
.block-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px; }
.block-subject { font-size: 14px; font-weight: 600; color: var(--text); letter-spacing: 0.02em; }
.block-meta { font-size: 10px; color: var(--text3); font-family: var(--font-mono); display: flex; gap: 14px; margin-bottom: 12px; flex-wrap: wrap; letter-spacing: 0.5px; }
.block-timer { font-family: var(--font-mono); font-size: 22px; color: var(--accent); text-align: center; padding: 8px 0; letter-spacing: 3px; font-weight: 700; }
.block-controls { display: flex; gap: 8px; flex-wrap: wrap; }
.block-progress { height: 3px; background: var(--bg3); border-radius: 2px; margin-top: 10px; overflow: hidden; }
.block-progress-fill { height: 100%; background: var(--accent); transition: width 0.3s; border-radius: 2px; }
.status-badge { font-size: 9px; font-family: var(--font-mono); padding: 3px 8px; border-radius: 4px; text-transform: uppercase; letter-spacing: 1.5px; font-weight: 600; }
.status-badge.idle { background: var(--bg3); color: var(--text3); }
.status-badge.running { background: rgba(0,255,136,0.12); color: var(--success); }
.status-badge.paused { background: rgba(255,165,2,0.12); color: var(--warn); }
.status-badge.done { background: rgba(100,100,100,0.15); color: var(--text3); }

/* Test log inline */
.test-log-row { display: flex; align-items: center; gap: 10px; margin-top: 10px; border-top: 1px solid var(--border); padding-top: 10px; }
.test-log-label { font-size: 10px; color: var(--text3); font-family: var(--font-mono); white-space: nowrap; }
.test-log-input { width: 72px; padding: 5px 8px; font-size: 11px; }
.test-efficiency-badge { font-family: var(--font-mono); font-size: 10px; padding: 3px 10px; background: var(--accent3); border-radius: 4px; color: var(--accent); font-weight: 600; }

/* Calendar */
.cal-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px; }
.cal-title { font-family: var(--font-mono); font-size: 14px; color: var(--accent); font-weight: 600; letter-spacing: 1px; }
.cal-grid { display: grid; grid-template-columns: repeat(7,1fr); gap: 3px; }
.cal-dayname { text-align: center; font-size: 9px; color: var(--text3); letter-spacing: 1.5px; padding: 10px 0; text-transform: uppercase; font-weight: 500; }
.cal-cell { min-height: 72px; background: var(--bg2); border: 1px solid var(--border); border-radius: var(--radius); padding: 8px; cursor: pointer; transition: all var(--transition); overflow: hidden; }
.cal-cell:hover { border-color: var(--accent3); background: var(--bg3); transform: translateY(-1px); }
.cal-cell.today { border-color: var(--accent); box-shadow: inset 0 0 0 1px var(--accent3); }
.cal-cell.other-month { opacity: 0.3; }
.cal-date { font-size: 11px; color: var(--text3); font-family: var(--font-mono); margin-bottom: 4px; font-weight: 500; }
.cal-cell.today .cal-date { color: var(--accent); font-weight: 700; }
.cal-block-dot { font-size: 9px; color: var(--accent); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.cal-exec-bar { height: 2px; background: var(--bg3); border-radius: 1px; margin-top: 4px; overflow: hidden; }
.cal-exec-fill { height: 100%; border-radius: 1px; }

/* Week grid */
.week-grid { display: grid; grid-template-columns: 50px repeat(7,1fr); border: 1px solid var(--border); border-radius: var(--radius); overflow: hidden; }
.week-time { background: var(--bg2); border-right: 1px solid var(--border); font-size: 9px; color: var(--text3); font-family: var(--font-mono); text-align: right; padding-right: 6px; line-height: 30px; height: 30px; }
.week-dayhead { background: var(--bg2); border-bottom: 1px solid var(--border); text-align: center; font-size: 10px; padding: 8px; color: var(--text3); font-weight: 500; }
.week-dayhead.today-col { color: var(--accent); background: var(--accent4); }
.week-cell { height: 30px; border-bottom: 1px solid var(--border); border-right: 1px solid var(--border); background: var(--bg1); position: relative; cursor: pointer; transition: background var(--transition); }
.week-cell:hover { background: var(--bg3); }
.week-block-item { position: absolute; left: 1px; right: 1px; background: var(--accent3); border-left: 2px solid var(--accent); border-radius: 3px; font-size: 8px; color: var(--accent); padding: 1px 4px; overflow: hidden; z-index: 5; cursor: pointer; }

/* Advisor messages */
.advisor-msg { background: var(--bg2); border: 1px solid var(--border); border-left: 3px solid var(--accent); border-radius: var(--radius); padding: 14px 16px; margin-bottom: 10px; font-size: 12px; color: var(--text2); font-family: var(--font-mono); animation: msgFade 0.35s ease; line-height: 1.7; }
@keyframes msgFade { from{opacity:0;transform:translateY(5px)} to{opacity:1;transform:translateY(0)} }
.advisor-msg.critical { border-left-color: var(--danger); background: rgba(255,71,87,0.03); }
.advisor-msg.warn { border-left-color: var(--warn); background: rgba(255,165,2,0.03); }
.advisor-msg.positive { border-left-color: var(--success); background: rgba(0,255,136,0.03); }

/* Habits */
.habit-item { display: flex; align-items: center; justify-content: space-between; padding: 14px 16px; background: var(--bg2); border: 1px solid var(--border); border-radius: var(--radius); margin-bottom: 10px; transition: all var(--transition); }
.habit-item:hover { border-color: var(--border2); }
.habit-name { font-size: 12px; color: var(--text); font-weight: 500; }
.habit-penalty { font-size: 10px; color: var(--danger); font-family: var(--font-mono); }
.habit-controls { display: flex; gap: 8px; }

/* Rank */
.rank-display { text-align: center; padding: 20px; }
.rank-icon { font-size: 44px; margin-bottom: 10px; }
.rank-name { font-family: var(--font-mono); font-size: 20px; color: var(--accent); letter-spacing: 5px; font-weight: 700; }
.rank-score { font-size: 11px; color: var(--text3); margin-top: 8px; }

/* Streaks */
.streak-item { display: flex; align-items: center; justify-content: space-between; padding: 12px 0; border-bottom: 1px solid var(--border); }
.streak-item:last-child { border-bottom: none; }
.streak-val { font-family: var(--font-mono); font-size: 26px; color: var(--accent); font-weight: 700; }
.streak-label { font-size: 11px; color: var(--text3); letter-spacing: 1px; }

/* Theme buttons */
.theme-btn { padding: 9px 16px; border-radius: var(--radius); font-size: 11px; font-family: var(--font-mono); cursor: pointer; border: 1px solid var(--border2); background: none; color: var(--text3); transition: all var(--transition); letter-spacing: 1.5px; font-weight: 500; }
.theme-btn:hover,.theme-btn.active { border-color: var(--accent); color: var(--accent); background: var(--accent4); }

/* TPI blocks */
.tpi-block { display: grid; grid-template-columns: repeat(3,1fr); gap: 14px; margin-bottom: 18px; }
.tpi-stat { text-align: center; padding: 16px; background: var(--bg2); border: 1px solid var(--border); border-radius: var(--radius); }
.tpi-val { font-family: var(--font-mono); font-size: 22px; font-weight: 700; color: var(--accent); }
.tpi-label { font-size: 9px; color: var(--text3); text-transform: uppercase; letter-spacing: 1.5px; margin-top: 6px; font-weight: 500; }

/* Exec score big */
.exec-score-big { font-family: var(--font-mono); font-size: 52px; font-weight: 700; color: var(--accent); text-align: center; padding: 10px 0; letter-spacing: 2px; text-shadow: 0 0 30px var(--accent3); }
.drag-over { border-color: var(--accent) !important; background: var(--accent4) !important; }

/* Performance bars */
.perf-bar-row { display: flex; gap: 4px; height: 60px; margin-top: 10px; align-items: flex-end; }
.perf-bar-col { flex: 1; display: flex; flex-direction: column; align-items: center; gap: 3px; }
.perf-bar { width: 100%; background: var(--accent); border-radius: 3px 3px 0 0; min-height: 2px; transition: height 0.3s ease; }
.perf-bar-day { font-size: 8px; color: var(--text3); font-family: var(--font-mono); font-weight: 500; }

/* Section headers */
.section-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 24px; }
.section-title { font-family: var(--font-mono); font-size: 12px; color: var(--text); letter-spacing: 3px; text-transform: uppercase; font-weight: 600; }
.section-title-accent { color: var(--accent); }
.divider { height: 1px; background: var(--border); margin: 24px 0; }
.mt-8 { margin-top: 8px; }
.mt-12 { margin-top: 12px; }
.mt-16 { margin-top: 16px; }
.mt-20 { margin-top: 20px; }
.text-accent { color: var(--accent); }
.text-muted { color: var(--text3); font-size: 11px; }
.text-danger { color: var(--danger); }
.text-warn { color: var(--warn); }
.font-mono { font-family: var(--font-mono); }
.hidden { display: none !important; }
.confirm-text { font-size: 13px; color: var(--text2); margin-bottom: 24px; line-height: 1.7; }
.confirm-actions { display: flex; gap: 12px; justify-content: flex-end; }

/* No data */
.no-data-inline { padding: 24px; text-align: center; color: var(--text3); font-size: 11px; font-family: var(--font-mono); border: 1px dashed var(--border2); border-radius: var(--radius); letter-spacing: 1px; }

/* ===== REPORT ENGINE STYLES ===== */
.report-filter-row { display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 20px; align-items: center; }
.report-date-range { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
.report-date-range input[type=date] { width: auto; }
.report-stat-card {
  background: var(--bg2);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 18px;
  position: relative;
  overflow: hidden;
  transition: all var(--transition);
  animation: statCardIn 0.4s cubic-bezier(.4,0,.2,1) both;
  box-shadow: 0 1px 4px rgba(0,0,0,0.12);
}
@keyframes statCardIn { from{opacity:0;transform:translateY(10px)} to{opacity:1;transform:translateY(0)} }
.report-stat-card:hover { border-color: var(--border2); transform: translateY(-1px); }
.report-stat-val { font-family: var(--font-mono); font-size: 24px; font-weight: 700; color: var(--accent); line-height: 1; }
.report-stat-label { font-size: 9px; color: var(--text3); letter-spacing: 2px; text-transform: uppercase; margin-top: 8px; font-weight: 500; }
.report-compare-arrow { position: absolute; top: 14px; right: 14px; font-size: 16px; }
.report-compare-val { font-size: 10px; color: var(--text3); font-family: var(--font-mono); margin-top: 6px; }
.arrow-up { color: var(--success); }
.arrow-down { color: var(--danger); }
.arrow-neutral { color: var(--text3); }

.mini-canvas-wrap { position: relative; width: 100%; height: 60px; }
.mini-canvas-wrap canvas { width: 100%; height: 60px; display: block; }
.mini-canvas-label { font-size: 9px; color: var(--text3); font-family: var(--font-mono); margin-top: 6px; text-align: center; font-weight: 500; }

.report-section-title { font-family: var(--font-mono); font-size: 10px; letter-spacing: 3px; color: var(--text3); text-transform: uppercase; margin: 28px 0 14px; border-bottom: 1px solid var(--border); padding-bottom: 10px; font-weight: 500; }

/* Human report */
.human-report {
  background: var(--bg2);
  border: 1px solid var(--border);
  border-radius: var(--radius2);
  padding: 32px;
  margin-top: 28px;
  box-shadow: var(--shadow-card);
}
.human-report-header { display: flex; align-items: center; gap: 14px; margin-bottom: 28px; }
.human-report-icon { font-size: 24px; }
.human-report-title { font-family: var(--font-mono); font-size: 12px; color: var(--accent); letter-spacing: 3px; text-transform: uppercase; font-weight: 700; }
.human-report-subtitle { font-size: 10px; color: var(--text3); margin-top: 3px; }
.report-paragraph {
  font-size: 13px;
  color: var(--text2);
  line-height: 1.85;
  margin-bottom: 20px;
  padding: 18px 22px;
  background: var(--bg1);
  border-left: 3px solid var(--border2);
  border-radius: 0 var(--radius) var(--radius) 0;
  transition: border-left-color var(--transition);
}
.report-paragraph.p-summary { border-left-color: var(--accent); }
.report-paragraph.p-comparison { border-left-color: var(--info); }
.report-paragraph.p-assessment { border-left-color: var(--warn); }
.report-paragraph.p-strategy { border-left-color: var(--success); }
.report-paragraph-tag { font-size: 8px; font-family: var(--font-mono); letter-spacing: 2.5px; text-transform: uppercase; color: var(--text3); display: block; margin-bottom: 10px; font-weight: 600; }
.report-paragraph em { color: var(--accent); font-style: normal; font-weight: 600; }
.report-paragraph strong { color: var(--text); }

.anomaly-badge { display: inline-block; background: rgba(255,71,87,0.10); border: 1px solid rgba(255,71,87,0.25); color: var(--danger); font-size: 9px; font-family: var(--font-mono); padding: 2px 8px; border-radius: 4px; margin-left: 8px; letter-spacing: 1px; font-weight: 600; }
.highlight-badge { display: inline-block; background: var(--accent3); border: 1px solid rgba(0,255,136,0.25); color: var(--accent); font-size: 9px; font-family: var(--font-mono); padding: 2px 8px; border-radius: 4px; margin-left: 8px; letter-spacing: 1px; font-weight: 600; }

.rating-distribution { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 10px; }
.rating-pill { padding: 5px 14px; border-radius: 14px; font-size: 10px; font-family: var(--font-mono); font-weight: 600; }
.rating-pill.overloaded { background: rgba(255,71,87,0.10); color: var(--danger); }
.rating-pill.heavy { background: rgba(255,165,2,0.10); color: var(--warn); }
.rating-pill.balanced { background: rgba(0,255,136,0.10); color: var(--success); }
.rating-pill.light { background: rgba(100,100,100,0.12); color: var(--text3); }

.report-empty { text-align: center; padding: 72px 24px; }
.report-empty-icon { font-size: 40px; margin-bottom: 18px; opacity: 0.6; }
.report-empty-title { font-family: var(--font-mono); font-size: 13px; color: var(--text3); letter-spacing: 3px; font-weight: 500; }
.report-empty-desc { font-size: 12px; color: var(--text3); margin-top: 10px; max-width: 420px; margin-left: auto; margin-right: auto; line-height: 1.7; }

/* Dual metric */
.dual-metric-row { display: grid; grid-template-columns: 1fr 1fr; gap: 2px; background: var(--border); border-radius: var(--radius); overflow: hidden; margin-top: 10px; }
.dual-metric-cell { background: var(--bg2); padding: 12px 14px; }
.dual-metric-val { font-family: var(--font-mono); font-size: 18px; font-weight: 700; }
.dual-metric-label { font-size: 9px; color: var(--text3); letter-spacing: 1.5px; text-transform: uppercase; margin-top: 3px; font-weight: 500; }
.dual-metric-cell.hours .dual-metric-val { color: var(--info); }
.dual-metric-cell.tests .dual-metric-val { color: var(--warn); }

/* Efficiency meter */
.efficiency-meter { margin-top: 14px; }
.efficiency-val-row { display: flex; justify-content: space-between; margin-bottom: 8px; }
.efficiency-big { font-family: var(--font-mono); font-size: 30px; color: var(--warn); font-weight: 700; }
.efficiency-label { font-size: 10px; color: var(--text3); margin-top: 5px; font-weight: 500; }

/* Subject intelligence */
.subject-cat-badge { display:inline-block;font-size:8px;font-family:var(--font-mono);padding:2px 7px;border-radius:3px;letter-spacing:1.5px;text-transform:uppercase;margin-left:8px;vertical-align:middle;background:var(--accent3);color:var(--accent);border:1px solid rgba(0,255,136,0.15);font-weight:600; }
.block-object { font-size:10px;color:var(--text3);font-family:var(--font-mono);margin-top:3px;padding:4px 0;border-top:1px solid var(--border);margin-top:8px;padding-top:8px;direction:rtl;unicode-bidi:bidi-override; }
.block-object.ltr { direction:ltr;unicode-bidi:normal; }

.subject-analytics-grid { display:grid;grid-template-columns:repeat(auto-fill,minmax(190px,1fr));gap:12px;margin-top:14px; }
.subj-card { background:var(--bg2);border:1px solid var(--border);border-left:3px solid var(--accent);border-radius:var(--radius);padding:14px;transition:all var(--transition); }
.subj-card:hover { border-color:var(--border2); }
.subj-card-name { font-size:11px;font-weight:700;color:var(--text);direction:rtl;unicode-bidi:bidi-override; }
.subj-card-name.ltr { direction:ltr;unicode-bidi:normal; }
.subj-card-stats { display:grid;grid-template-columns:1fr 1fr;gap:6px;margin-top:10px; }
.subj-stat { text-align:center; }
.subj-stat-val { font-family:var(--font-mono);font-size:15px;color:var(--accent);font-weight:700; }
.subj-stat-label { font-size:8px;color:var(--text3);letter-spacing:1.5px;text-transform:uppercase;font-weight:500; }
.subj-dominance-bar { height:3px;background:var(--bg3);border-radius:2px;margin-top:10px;overflow:hidden; }
.subj-dominance-fill { height:100%;background:var(--accent);border-radius:2px; }
.neglected-badge { display:inline-block;background:rgba(255,71,87,0.10);border:1px solid rgba(255,71,87,0.25);color:var(--danger);font-size:8px;font-family:var(--font-mono);padding:2px 7px;border-radius:3px;margin-left:6px;font-weight:600; }

/* Heatmap */
.heatmap-container { overflow-x:auto;margin-top:14px; }
.heatmap-table { border-collapse:collapse;width:100%;min-width:600px; }
.heatmap-table th,.heatmap-table td { border:1px solid var(--border);padding:7px 9px;font-size:10px;font-family:var(--font-mono);text-align:center;white-space:nowrap; }
.heatmap-table th { background:var(--bg3);color:var(--text3);font-size:9px;letter-spacing:1.5px;font-weight:600; }
.heatmap-table td:first-child { background:var(--bg2);color:var(--text3);text-align:left;font-size:9px; }
.heatmap-cell-0 { background:rgba(0,255,136,0.02);color:var(--text3); }
.heatmap-cell-1 { background:rgba(0,255,136,0.08);color:var(--text3); }
.heatmap-cell-2 { background:rgba(0,255,136,0.18);color:var(--text2); }
.heatmap-cell-3 { background:rgba(0,255,136,0.34);color:var(--text); }
.heatmap-cell-4 { background:rgba(0,255,136,0.56);color:#000; }

/* Report export row */
.report-export-row { display:flex;gap:10px;flex-wrap:wrap;margin-bottom:18px; }

/* ===== JOURNAL EXPORT STYLES ===== */
.jrnl-mode-row { display: flex; gap: 12px; margin-bottom: 22px; flex-wrap: wrap; }
.jrnl-mode-btn { padding: 9px 22px; border-radius: var(--radius); font-size: 11px; font-family: var(--font-mono); cursor: pointer; border: 1px solid var(--border2); background: none; color: var(--text3); transition: all var(--transition); letter-spacing: 1.5px; text-transform: uppercase; font-weight: 500; }
.jrnl-mode-btn:hover { border-color: var(--accent); color: var(--accent); }
.jrnl-mode-btn.active { background: var(--accent); color: #000; border-color: var(--accent); font-weight: 700; }
.jrnl-pdf-theme-row { display: flex; gap: 12px; }
.jrnl-pdf-dark { border-color: var(--border2); color: var(--text3); }
.jrnl-pdf-dark.active { background: #1a1a1a; border-color: var(--text2); color: var(--text); }
.jrnl-pdf-light { border-color: var(--border2); color: var(--text3); }
.jrnl-pdf-light.active { background: #f0f0f0; border-color: #999; color: #1a1a1a; }
.jrnl-preview-card { background: var(--bg2); border: 1px solid var(--border); border-radius: var(--radius2); overflow: hidden; box-shadow: var(--shadow-card); }
.jrnl-preview-header { background: var(--bg3); border-bottom: 1px solid var(--border); padding: 12px 18px; font-family: var(--font-mono); font-size: 9px; letter-spacing: 2.5px; color: var(--text3); text-transform: uppercase; display: flex; align-items: center; justify-content: space-between; font-weight: 500; }
.jrnl-page-list { padding: 14px 18px; }
.jrnl-page-item { display: flex; align-items: center; gap: 12px; padding: 10px 0; border-bottom: 1px solid var(--border); font-size: 11px; color: var(--text2); }
.jrnl-page-item:last-child { border-bottom: none; }
.jrnl-page-num { font-family: var(--font-mono); font-size: 10px; color: var(--text3); min-width: 42px; font-weight: 500; }
.jrnl-page-desc { flex: 1; }
.jrnl-page-blocks { font-family: var(--font-mono); font-size: 10px; color: var(--accent); font-weight: 600; }
.jrnl-gen-progress { display: none; align-items: center; gap: 14px; padding: 14px 18px; background: var(--accent4); border-top: 1px solid var(--accent3); font-size: 11px; font-family: var(--font-mono); color: var(--accent); font-weight: 500; }
.jrnl-gen-progress.active { display: flex; }
.jrnl-spinner { width: 14px; height: 14px; border: 2px solid var(--accent3); border-top-color: var(--accent); border-radius: 50%; animation: spin 0.7s linear infinite; flex-shrink: 0; }
@keyframes spin { to { transform: rotate(360deg); } }
.jrnl-week-range-label { font-size: 10px; font-family: var(--font-mono); color: var(--accent); margin-top: 10px; min-height: 16px; font-weight: 500; }
.jrnl-info-row { display: flex; gap: 18px; flex-wrap: wrap; margin-top: 14px; }
.jrnl-info-item { font-size: 10px; color: var(--text3); font-family: var(--font-mono); }
.jrnl-info-item span { color: var(--text2); }
</style>
</head>
<body>

<div id="commandBanner">⚠ COMMAND MODE ACTIVATED — EXECUTION BELOW THRESHOLD FOR 3 CONSECUTIVE DAYS. IMMEDIATE CORRECTIVE ACTION REQUIRED.</div>
<div id="backupBanner"><span>⚠ BACKUP RECOMMENDED — PROTECT YOUR PROGRESS</span><button class="btn btn-sm" onclick="exportBackup()">EXPORT NOW</button></div>

<header id="appHeader">
  <div class="header-brand">
    <div class="brand-name">EXECUTION ENGINE</div>
    <div class="brand-sub">Tactical Advisor Edition · 12 Hour Protocol</div>
  </div>
  <div class="header-mission">
    <div id="missionCountdown" class="tpi-green">NO MISSION SET</div>
    <div class="header-rank">RANK: <span id="headerRank">—</span></div>
  </div>
</header>

<nav id="mainNav">
  <button class="nav-btn active" onclick="switchView('dashboard',this)">DASHBOARD</button>
  <button class="nav-btn" onclick="switchView('blocks',this)">STUDY BLOCKS</button>
  <button class="nav-btn" onclick="switchView('calendar',this)">CALENDAR</button>
  <button class="nav-btn" onclick="switchView('mission',this)">MISSION</button>
  <button class="nav-btn" onclick="switchView('report',this)">REPORT</button>
  <button class="nav-btn" onclick="switchView('advisor',this)">ADVISOR</button>
  <button class="nav-btn" onclick="switchView('habits',this)">HABITS</button>
  <button class="nav-btn" onclick="switchView('journal',this)">JOURNAL PDF</button>
  <button class="nav-btn" onclick="switchView('settings',this)">SETTINGS</button>
</nav>

<main id="appContent">

  <!-- DASHBOARD -->
  <div id="view-dashboard" class="view active">
    <div class="card card-accent" style="margin-bottom:16px">
      <div class="card-title"><span class="dot"></span>PERFORMANCE METRICS</div>
      <div class="metrics-row" id="metricsRow">
        <div class="metric-ring ring-tooltip">
          <svg class="ring-svg" viewBox="0 0 80 80"><circle class="ring-track" cx="40" cy="40" r="32"/><circle class="ring-fill" id="ring-Focus" cx="40" cy="40" r="32" stroke-dasharray="201" stroke-dashoffset="201"/></svg>
          <div class="ring-val" id="val-Focus">50</div>
          <div class="ring-label">Focus</div>
          <div class="tooltip-text">Lost 2pts per interruption. Restored by unbroken deep work sessions.</div>
        </div>
        <div class="metric-ring ring-tooltip">
          <svg class="ring-svg" viewBox="0 0 80 80"><circle class="ring-track" cx="40" cy="40" r="32"/><circle class="ring-fill" id="ring-Discipline" cx="40" cy="40" r="32" stroke-dasharray="201" stroke-dashoffset="201"/></svg>
          <div class="ring-val" id="val-Discipline">50</div>
          <div class="ring-label">Discipline</div>
          <div class="tooltip-text">Penalized by late starts. Rewarded by habit avoidance and on-time execution.</div>
        </div>
        <div class="metric-ring ring-tooltip">
          <svg class="ring-svg" viewBox="0 0 80 80"><circle class="ring-track" cx="40" cy="40" r="32"/><circle class="ring-fill" id="ring-Momentum" cx="40" cy="40" r="32" stroke-dasharray="201" stroke-dashoffset="201"/></svg>
          <div class="ring-val" id="val-Momentum">50</div>
          <div class="ring-label">Momentum</div>
          <div class="tooltip-text">Builds with consecutive high-execution days. Breaks with habits or long delays.</div>
        </div>
        <div class="metric-ring ring-tooltip">
          <svg class="ring-svg" viewBox="0 0 80 80"><circle class="ring-track" cx="40" cy="40" r="32"/><circle class="ring-fill" id="ring-Execution" cx="40" cy="40" r="32" stroke-dasharray="201" stroke-dashoffset="201"/></svg>
          <div class="ring-val" id="val-Execution">0</div>
          <div class="ring-label">Execution</div>
          <div class="tooltip-text">Weighted: Study Hours ×0.4 + Block Completion ×0.2 + Test Volume ×0.4</div>
        </div>
      </div>
    </div>

    <div class="grid-2" style="margin-bottom:16px">
      <div class="card">
        <div class="card-title"><span class="dot"></span>TODAY'S EXECUTION</div>
        <div class="exec-score-big" id="execScoreBig">0%</div>
        <div style="display:flex;gap:16px;justify-content:center;margin-top:8px;flex-wrap:wrap">
          <div style="text-align:center">
            <div class="font-mono" style="font-size:18px;color:var(--info)" id="dash-completed">0h</div>
            <div class="text-muted">STUDY HRS</div>
          </div>
          <div style="text-align:center">
            <div class="font-mono" style="font-size:18px;color:var(--text3)" id="dash-planned">0h</div>
            <div class="text-muted">PLANNED</div>
          </div>
          <div style="text-align:center">
            <div class="font-mono" style="font-size:18px;color:var(--warn)" id="dash-tests">0</div>
            <div class="text-muted">TESTS DONE</div>
          </div>
          <div style="text-align:center">
            <div class="font-mono" style="font-size:18px;color:var(--text3)" id="dash-testsTarget">0</div>
            <div class="text-muted">TARGET TESTS</div>
          </div>
        </div>
        <div class="block-progress" style="margin-top:14px"><div class="block-progress-fill" id="execProgressBar" style="width:0%"></div></div>
        <!-- TEST EFFICIENCY -->
        <div class="efficiency-meter">
          <div class="efficiency-val-row">
            <div>
              <div class="efficiency-big" id="testEfficiencyVal">—</div>
              <div class="efficiency-label">TEST EFFICIENCY (tests/hr)</div>
            </div>
            <div style="text-align:right">
              <div class="font-mono" style="font-size:13px;color:var(--text3)" id="testEfficiencyRating">awaiting data</div>
              <div class="efficiency-label">EFFICIENCY RATING</div>
            </div>
          </div>
          <div class="block-progress"><div class="block-progress-fill" id="testEfficiencyBar" style="width:0%;background:var(--warn)"></div></div>
        </div>
      </div>

      <div class="card">
        <div class="card-title"><span class="dot"></span>FATIGUE INTELLIGENCE</div>
        <div class="fatigue-bar-wrap">
          <div class="fatigue-label-row">
            <span id="fatigueLabel">AWAITING DATA</span>
            <span id="fatigueVal" class="font-mono" style="color:var(--accent)">—</span>
          </div>
          <div class="fatigue-bar-track"><div class="fatigue-bar-fill" id="fatigueBar" style="width:0%"></div></div>
          <div style="display:flex;justify-content:space-between;margin-top:4px;font-size:9px;color:var(--text3)">
            <span>CRITICAL</span><span>BURNOUT</span><span>WARNING</span><span>ELEVATED</span><span>STABLE</span>
          </div>
        </div>
        <div class="text-muted mt-12" id="fatigueAdvice">Log study sessions to enable fatigue monitoring.</div>
        <div class="dual-metric-row mt-12">
          <div class="dual-metric-cell hours">
            <div class="dual-metric-val" id="dash-hoursTotal">0h</div>
            <div class="dual-metric-label">Hours Today</div>
          </div>
          <div class="dual-metric-cell tests">
            <div class="dual-metric-val" id="dash-testsTotal">0</div>
            <div class="dual-metric-label">Tests Today</div>
          </div>
        </div>
      </div>
    </div>

    <div class="grid-3" style="margin-bottom:16px">
      <div class="card">
        <div class="card-title"><span class="dot"></span>STREAKS</div>
        <div class="streak-item">
          <div><div class="streak-val" id="studyStreakVal">0</div><div class="streak-label">STUDY STREAK</div></div>
          <div class="text-muted">≥85% EXEC</div>
        </div>
        <div class="streak-item">
          <div><div class="streak-val" id="deepWorkStreakVal">0</div><div class="streak-label">DEEP WORK</div></div>
          <div class="text-muted">≥4 BLOCKS</div>
        </div>
      </div>
      <div class="card">
        <div class="card-title"><span class="dot"></span>RANK</div>
        <div class="rank-display" style="padding:8px">
          <div class="rank-icon" id="rankIcon">⚙</div>
          <div class="rank-name" id="rankName">IRON</div>
          <div class="rank-score" id="rankScore">No activity logged yet</div>
        </div>
      </div>
      <div class="card">
        <div class="card-title"><span class="dot"></span>7-DAY HISTORY</div>
        <div class="perf-bar-row" id="perfBars"><div class="text-muted" style="font-size:10px">No history yet</div></div>
      </div>
    </div>

    <div class="card">
      <div class="card-title"><span class="dot"></span>SESSION SETUP</div>
      <div class="grid-4">
        <div class="input-group">
          <label class="input-label">Planned Hours Today</label>
          <input type="number" id="plannedHoursInput" min="0.5" max="16" step="0.5" placeholder="e.g. 8">
        </div>
        <div class="input-group">
          <label class="input-label">Daily Test Target</label>
          <input type="number" id="dailyTestTarget" min="0" placeholder="e.g. 50">
        </div>
        <div class="input-group">
          <label class="input-label">Weekly Test Target</label>
          <input type="number" id="weeklyTestTarget" min="0" placeholder="e.g. 200">
        </div>
        <div style="display:flex;align-items:flex-end;padding-bottom:14px">
          <button class="btn btn-primary" onclick="savePlannedHours()" style="width:100%">SET TARGETS</button>
        </div>
      </div>
    </div>
  </div>

  <!-- STUDY BLOCKS -->
  <div id="view-blocks" class="view">
    <div class="section-header">
      <div class="section-title">STUDY <span class="section-title-accent">BLOCKS</span></div>
      <button class="btn btn-primary" onclick="openAddBlock()">+ ADD BLOCK</button>
    </div>
    <div id="blocksList"></div>
  </div>

  <!-- CALENDAR -->
  <div id="view-calendar" class="view">
    <div class="section-header">
      <div class="section-title">TACTICAL <span class="section-title-accent">CALENDAR</span></div>
      <div style="display:flex;gap:8px">
        <button class="btn btn-sm" id="calViewMonth" onclick="setCalView('month')">MONTH</button>
        <button class="btn btn-sm" id="calViewWeek" onclick="setCalView('week')">WEEK</button>
        <button class="btn btn-sm" id="calViewDay" onclick="setCalView('day')">DAY</button>
      </div>
    </div>
    <div id="calView-month" class="card">
      <div class="cal-header">
        <button class="btn btn-sm" onclick="calNav(-1)">‹ PREV</button>
        <div class="cal-title" id="calMonthTitle"></div>
        <button class="btn btn-sm" onclick="calNav(1)">NEXT ›</button>
      </div>
      <div class="cal-grid" id="calGrid"></div>
    </div>
    <div id="calView-week" class="hidden card">
      <div class="cal-header">
        <button class="btn btn-sm" onclick="weekNav(-1)">‹ PREV</button>
        <div class="cal-title" id="calWeekTitle"></div>
        <button class="btn btn-sm" onclick="weekNav(1)">NEXT ›</button>
      </div>
      <div class="week-grid" id="weekGrid" style="overflow:auto"></div>
    </div>
    <div id="calView-day" class="hidden">
      <div class="card" style="margin-bottom:16px">
        <div class="cal-header">
          <button class="btn btn-sm" onclick="dayNav(-1)">‹ PREV</button>
          <div class="cal-title" id="calDayTitle"></div>
          <button class="btn btn-sm" onclick="dayNav(1)">NEXT ›</button>
        </div>
      </div>
      <div class="grid-2">
        <div class="card">
          <div class="card-title"><span class="dot"></span>DAILY PANEL</div>
          <div class="tpi-block" id="dayPanelStats"></div>
          <div id="dayTacticalRating" class="advisor-msg positive" style="margin-top:8px"></div>
        </div>
        <div class="card">
          <div class="card-title"><span class="dot"></span>BLOCKS THIS DAY</div>
          <div id="dayBlocksList"></div>
          <button class="btn btn-sm mt-12" onclick="openAddBlockForDate()">+ ADD BLOCK</button>
        </div>
      </div>
    </div>
  </div>

  <!-- MISSION -->
  <div id="view-mission" class="view">
    <div class="section-header">
      <div class="section-title">MISSION <span class="section-title-accent">PRESSURE ENGINE</span></div>
    </div>
    <div class="grid-2" style="margin-bottom:16px">
      <div class="card">
        <div class="card-title"><span class="dot"></span>MISSION SETUP</div>
        <div class="input-group">
          <label class="input-label">Mission Name</label>
          <input type="text" id="missionName" placeholder="e.g. Final Exam Preparation">
        </div>
        <div class="input-group">
          <label class="input-label">Target Date</label>
          <input type="date" id="missionDate">
        </div>
        <div class="input-group">
          <label class="input-label">Total Required Hours</label>
          <input type="number" id="missionHours" placeholder="e.g. 500">
        </div>
        <div class="input-group">
          <label class="input-label">Total Required Tests</label>
          <input type="number" id="missionTestsRequired" placeholder="e.g. 2000">
        </div>
        <button class="btn btn-primary" onclick="saveMission()">LOCK IN MISSION</button>
      </div>
      <div class="card card-accent">
        <div class="card-title"><span class="dot"></span>MISSION STATUS</div>
        <div id="missionNoData" class="no-data-inline">No mission configured. Define your objective.</div>
        <div id="missionActivePanel" style="display:none">
          <div class="tpi-block" id="missionStats"></div>
          <div id="tpiMeter" style="margin-top:12px">
            <div style="display:flex;justify-content:space-between;margin-bottom:6px">
              <span class="text-muted">TIME PRESSURE INDEX</span>
              <span class="font-mono" id="tpiVal" style="color:var(--accent)">—</span>
            </div>
            <div class="block-progress"><div class="block-progress-fill" id="tpiBar" style="width:0%"></div></div>
          </div>
          <div class="dual-metric-row mt-12">
            <div class="dual-metric-cell hours">
              <div class="dual-metric-val" id="missionHoursLeft">—</div>
              <div class="dual-metric-label">Hours Remaining</div>
            </div>
            <div class="dual-metric-cell tests">
              <div class="dual-metric-val" id="missionTestsLeft">—</div>
              <div class="dual-metric-label">Tests Remaining</div>
            </div>
          </div>
          <div id="missionAdvisor" class="advisor-msg mt-12" style="display:none"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- REPORT ENGINE -->
  <div id="view-report" class="view">
    <div class="section-header">
      <div class="section-title">PERFORMANCE <span class="section-title-accent">REPORT ENGINE</span></div>
      <div style="display:flex;gap:8px;flex-wrap:wrap">
        <button class="btn btn-primary btn-sm" onclick="generateReport()">GENERATE REPORT</button>
        <button class="btn btn-sm" onclick="exportOperationalDayPDF()">DAY PDF (OPS)</button>
        <button class="btn btn-sm" onclick="exportOperationalWeekPDF()">WEEK PDF (OPS)</button>
        <button class="btn btn-sm" style="border-color:var(--accent);color:var(--accent)" onclick="exportFullAnalyticalPDF()">EXPORT FULL ANALYTICAL PDF</button>
      </div>
    </div>

    <!-- FILTER ROW -->
    <div class="card" style="margin-bottom:16px">
      <div class="card-title"><span class="dot"></span>TIME RANGE SELECTION</div>
      <div class="report-filter-row">
        <button class="btn btn-sm" id="rq-thisweek" onclick="setReportQuick('thisweek')">THIS WEEK</button>
        <button class="btn btn-sm" id="rq-lastweek" onclick="setReportQuick('lastweek')">LAST WEEK</button>
        <button class="btn btn-sm" id="rq-thismonth" onclick="setReportQuick('thismonth')">THIS MONTH</button>
        <button class="btn btn-sm" id="rq-last30" onclick="setReportQuick('last30')">LAST 30 DAYS</button>
        <button class="btn btn-sm" id="rq-custom" onclick="setReportQuick('custom')">CUSTOM</button>
        <div class="report-date-range" id="reportCustomRange" style="display:none">
          <input type="date" id="reportStart" style="width:140px">
          <span style="color:var(--text3);font-size:11px">TO</span>
          <input type="date" id="reportEnd" style="width:140px">
        </div>
      </div>
      <div style="font-size:10px;color:var(--text3);font-family:var(--font-mono)" id="reportRangeLabel">No range selected</div>
    </div>

    <div id="reportOutput">
      <div class="report-empty">
        <div class="report-empty-icon">◈</div>
        <div class="report-empty-title">SELECT A TIME RANGE TO BEGIN ANALYSIS</div>
        <div class="report-empty-desc">The system will generate a full comparative performance analysis including behavioral patterns, trend data, and strategic advice.</div>
      </div>
    </div>
  </div>

  <!-- ADVISOR -->
  <div id="view-advisor" class="view">
    <div class="section-header">
      <div class="section-title">AI <span class="section-title-accent">ADVISORY ENGINE</span></div>
      <button class="btn btn-sm" onclick="generateAdvisory()">REFRESH ANALYSIS</button>
    </div>
    <div id="advisoryList"><div class="no-data-inline">Click REFRESH ANALYSIS to generate insights based on your logged data.</div></div>
  </div>

  <!-- HABITS -->
  <div id="view-habits" class="view">
    <div class="section-header">
      <div class="section-title">HABIT <span class="section-title-accent">TRACKING</span></div>
      <button class="btn btn-primary" onclick="openAddHabit()">+ ADD HABIT</button>
    </div>
    <div id="habitsList"></div>
    <div class="card mt-16">
      <div class="card-title"><span class="dot"></span>TODAY'S HABIT LOG</div>
      <div id="habitDailyLog"></div>
    </div>
  </div>

  <!-- JOURNAL PDF EXPORT -->
  <div id="view-journal" class="view">
    <div class="section-header">
      <div class="section-title">JOURNAL <span class="section-title-accent">PDF EXPORT</span></div>
    </div>

    <div class="grid-2" style="margin-bottom:16px">
      <!-- Left: mode + config -->
      <div>
        <div class="card" style="margin-bottom:16px">
          <div class="card-title"><span class="dot"></span>EXPORT MODE</div>
          <div class="jrnl-mode-row">
            <button class="jrnl-mode-btn active" id="jm-day" onclick="setJournalMode('day')">SINGLE DAY (OPS)</button>
            <button class="jrnl-mode-btn" id="jm-week" onclick="setJournalMode('week')">WEEKLY (OPS · 1 PAGE)</button>
          </div>
          <div id="jrnlDayOpts">
            <div class="input-group" style="margin-bottom:0">
              <label class="input-label">Select Date</label>
              <input type="date" id="jrnlDayDate" onchange="updateJournalPreview()">
            </div>
          </div>
          <div id="jrnlWeekOpts" style="display:none">
            <div class="grid-2" style="gap:12px">
              <div class="input-group" style="margin-bottom:0">
                <label class="input-label">Any Date in the Week</label>
                <input type="date" id="jrnlWeekRefDate" onchange="updateJournalPreview()">
              </div>
              <div class="input-group" style="margin-bottom:0">
                <label class="input-label">Week Starts On</label>
                <select id="jrnlWeekStartDay" onchange="updateJournalPreview()">
                  <option value="0">Sunday</option>
                  <option value="1" selected>Monday</option>
                  <option value="6">Saturday</option>
                </select>
              </div>
            </div>
            <div class="jrnl-week-range-label" id="jrnlWeekRangeLabel">Select a date to compute week range.</div>
          </div>
        </div>
        <div class="card">
          <div class="card-title"><span class="dot"></span>PDF THEME <span style="font-size:8px;color:var(--text3);margin-left:8px">(PDF ONLY — APP THEMES UNCHANGED)</span></div>
          <div class="jrnl-pdf-theme-row">
            <button class="jrnl-mode-btn" id="jpt-dark" onclick="setJournalPdfTheme('dark')">◼ DARK</button>
            <button class="jrnl-mode-btn active" id="jpt-light" onclick="setJournalPdfTheme('light')">◻ LIGHT (PRINT)</button>
          </div>
          <div class="text-muted mt-8" style="line-height:1.7">
            Light: white background, dark text — optimised for printing.<br>
            Dark: #0f0f0f background, accent text — for digital review.
          </div>
          <div style="margin-top:14px;display:flex;gap:10px;flex-wrap:wrap">
            <button class="btn btn-primary" id="jrnlGenerateBtn" onclick="triggerJournalGenerate()">GENERATE OPERATIONAL PDF</button>
            <button class="btn" style="border-color:var(--accent);color:var(--accent)" onclick="exportFullAnalyticalPDF()">EXPORT FULL ANALYTICAL PDF</button>
          </div>
        </div>
      </div>

      <!-- Right: preview + structure -->
      <div>
        <div class="jrnl-preview-card">
          <div class="jrnl-preview-header">
            <span>EXPORT PREVIEW</span>
            <span id="jrnlPageCount" style="color:var(--accent)">—</span>
          </div>
          <div class="jrnl-page-list" id="jrnlPageList">
            <div class="text-muted" style="padding:12px 0;font-size:11px;font-family:var(--font-mono)">Configure options to preview export structure.</div>
          </div>
          <div class="jrnl-gen-progress" id="jrnlProgress">
            <div class="jrnl-spinner"></div>
            <span id="jrnlProgressText">Rendering pages…</span>
          </div>
        </div>
        <div class="card mt-16">
          <div class="card-title"><span class="dot"></span>DOCUMENT STRUCTURE</div>
          <div class="text-muted" style="font-size:11px;line-height:2">
            <strong style="color:var(--accent2)">OPERATIONAL DAILY →</strong> 1 page: summary stats, subject breakdown, compact advisory, structured to-do table (Subject, Object, Duration, Tests, Priority, Status, Notes)<br>
            <strong style="color:var(--accent2)">OPERATIONAL WEEKLY →</strong> 1 single A4 page: weekly summary, 6-8 line executive summary, mini performance chart, <strong>8×9 subject heatmap matrix</strong><br>
            <strong style="color:var(--accent)">FULL ANALYTICAL PDF →</strong> multi-page: all charts, heatmap, full 5-paragraph advisory, subject analytics, comparisons, trends<br>
            <strong style="color:var(--text2)">8×9 MATRIX →</strong> زیست | شیمی | فیزیک | ریاضی | زبان | عربی | فارسی | دینی · hours/tests per day · dynamic color intensity
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- SETTINGS -->
  <div id="view-settings" class="view">    <div class="section-header">
      <div class="section-title">SYSTEM <span class="section-title-accent">SETTINGS</span></div>
    </div>
    <div class="grid-2">
      <div class="card">
        <div class="card-title"><span class="dot"></span>THEME</div>
        <div style="display:flex;gap:10px;flex-wrap:wrap">
          <button class="theme-btn active" id="theme-obsidian" onclick="setTheme('obsidian')">OBSIDIAN</button>
          <button class="theme-btn" id="theme-midnight" onclick="setTheme('midnight')">MIDNIGHT BLUE</button>
          <button class="theme-btn" id="theme-graphite" onclick="setTheme('graphite')">GRAPHITE</button>
        </div>
      </div>
      <div class="card">
        <div class="card-title"><span class="dot"></span>BACKUP SYSTEM</div>
        <div style="display:flex;gap:10px;flex-wrap:wrap">
          <button class="btn btn-primary" onclick="exportBackup()">EXPORT BACKUP</button>
          <button class="btn" onclick="document.getElementById('importFile').click()">IMPORT BACKUP</button>
          <input type="file" id="importFile" accept=".json" style="display:none" onchange="importBackup(event)">
        </div>
        <div class="text-muted mt-12" id="lastBackupInfo">Last backup: never</div>
      </div>
    </div>
    <div class="card mt-16">
      <div class="card-title"><span class="dot"></span>RESET / DANGER ZONE</div>
      <div style="display:flex;gap:10px">
        <button class="btn btn-danger" onclick="confirmReset()">RESET ALL DATA</button>
      </div>
      <div class="text-muted mt-8">All data will be permanently erased from IndexedDB.</div>
    </div>
  </div>

</main>

<!-- ADD BLOCK MODAL -->
<div class="modal-overlay" id="addBlockModal">
  <div class="modal">
    <div class="modal-title"><span id="blockModalTitle">ADD STUDY BLOCK</span><button class="modal-close" onclick="closeModal('addBlockModal')">×</button></div>
    <input type="hidden" id="editBlockId">
    <div class="input-group">
      <label class="input-label">Subject (زیست، شیمی، Math, Physics…)</label>
      <input type="text" id="blockSubject" placeholder="e.g. ریاضی تجربی / Advanced Physics">
    </div>
    <div class="input-group">
      <label class="input-label">Object / Description (e.g. مشتق ویدئو ۲ — display only, not classified)</label>
      <input type="text" id="blockObject" placeholder="Optional: topic or task description" style="direction:rtl">
    </div>
    <div class="grid-2" style="gap:10px">
      <div class="input-group">
        <label class="input-label">Planned Duration (minutes)</label>
        <input type="number" id="blockDuration" placeholder="90" min="5">
      </div>
      <div class="input-group">
        <label class="input-label">Planned Start Time</label>
        <input type="time" id="blockStartTime">
      </div>
    </div>
    <div class="grid-2" style="gap:10px">
      <div class="input-group">
        <label class="input-label">Target Tests (planned)</label>
        <input type="number" id="blockTests" placeholder="0" min="0">
      </div>
      <div class="input-group">
        <label class="input-label">Completed Tests</label>
        <input type="number" id="blockCompletedTests" placeholder="0" min="0">
      </div>
    </div>
    <div class="input-group">
      <label class="input-label">Date</label>
      <input type="date" id="blockDate">
    </div>
    <button class="btn btn-primary" style="width:100%;margin-top:4px" onclick="saveBlock()">SAVE BLOCK</button>
  </div>
</div>

<!-- ADD HABIT MODAL -->
<div class="modal-overlay" id="addHabitModal">
  <div class="modal">
    <div class="modal-title"><span>ADD BAD HABIT</span><button class="modal-close" onclick="closeModal('addHabitModal')">×</button></div>
    <div class="input-group">
      <label class="input-label">Habit Name</label>
      <input type="text" id="habitName" placeholder="e.g. Social Media">
    </div>
    <div class="input-group">
      <label class="input-label">Penalty Value (when performed)</label>
      <input type="number" id="habitPenalty" placeholder="3" min="1" max="10">
    </div>
    <button class="btn btn-primary" style="width:100%" onclick="saveHabit()">SAVE HABIT</button>
  </div>
</div>

<!-- CONFIRM MODAL -->
<div class="modal-overlay" id="confirmModal">
  <div class="modal" style="max-width:380px">
    <div class="modal-title"><span id="confirmTitle">CONFIRM</span><button class="modal-close" onclick="closeModal('confirmModal')">×</button></div>
    <div class="confirm-text" id="confirmText"></div>
    <div class="confirm-actions">
      <button class="btn" onclick="closeModal('confirmModal')">CANCEL</button>
      <button class="btn btn-danger" id="confirmOkBtn">CONFIRM</button>
    </div>
  </div>
</div>

<script>
'use strict';
// ================================================================
// SUBJECT INTELLIGENCE — Classification Engine
// Normalizes Persian/English text, detects keywords
// Returns one of 8 matrix categories or 'General'
// Object field is NEVER classified — display only
// ================================================================
const SUBJECT_MATRIX_LABELS = ['زیست','شیمی','فیزیک','ریاضی','زبان','عربی','فارسی','دینی'];
const SUBJECT_RULES = [
  { cat:'زیست',    en:'Biology',     kw:['زیست','biology','biochem','biolog','physiology','anatomy','zoology','botany','microbio','اکولوژی','ژنتیک','genetics','evolution','ecology'] },
  { cat:'شیمی',    en:'Chemistry',   kw:['شیمی','chemi','organic','inorganic','thermochem','electrochemi','polymer','catalyst'] },
  { cat:'فیزیک',   en:'Physics',     kw:['فیزیک','physics','mechanic','wave','optic','electr','thermodynam','quantum','relativity','فیزیک'] },
  { cat:'ریاضی',   en:'Mathematics', kw:['ریاضی','math','algebra','calculus','geometry','statistic','probabilit','linear','integral','derivative','تفاضل','حساب','آمار','احتمال','هندسه','جبر','مشتق','انتگرال','ترکیبیات','combinat','numeric','محاسب'] },
  { cat:'زبان',    en:'Language',    kw:['زبان','english','language','vocab','grammar','reading','listening','writing','toefl','ielts','speaking'] },
  { cat:'عربی',    en:'Arabic',      kw:['عربی','arabic','arab','نحو','صرف','قرائت عربی'] },
  { cat:'فارسی',   en:'Literature',  kw:['فارسی','ادبیات','literature','persian','شعر','نثر','تاریخ ادبیات','آرایه','قرائت فارسی','دستور زبان فارسی'] },
  { cat:'دینی',    en:'Humanities',  kw:['دینی','دین','religion','religious','قرآن','قران','theology','اخلاق','معارف','احکام'] },
];
function classifySubject(text) {
  if (!text) return 'General';
  const low = text.toLowerCase().replace(/[-–—]/g,' ');
  for (const rule of SUBJECT_RULES) {
    for (const kw of rule.kw) {
      if (low.includes(kw)) return rule.cat;
    }
  }
  // Broad English fallbacks
  if (/\b(histo|social|civics|econom|geography|geograph|جغرافیا|تاریخ|اجتماعی|psychology|psycholog)\b/.test(low)) return 'دینی'; // Humanities group
  return 'General';
}
function subjectCatColor(cat) {
  const map = {'زیست':'#00cc6a','شیمی':'#00aaff','فیزیک':'#aa44ff','ریاضی':'#ffaa00','زبان':'#ff6688','عربی':'#ff8844','فارسی':'#44ffcc','دینی':'#88ccff','General':'#666','Biology':'#00cc6a','Chemistry':'#00aaff','Physics':'#aa44ff','Mathematics':'#ffaa00','Language':'#ff6688','Arabic':'#ff8844','Literature':'#44ffcc','Humanities':'#88ccff'};
  return map[cat] || '#666666';
}
function isRTL(text) {
  if (!text) return false;
  return /[\u0600-\u06FF\u0750-\u077F]/.test(text);
}

// ================================================================
// DATABASE
// ================================================================
let db = null;
const DB_NAME = 'ExecutionEngineDB';
const DB_VERSION = 2;

function initDB() {
  return new Promise((res,rej) => {
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = e => {
      const d = e.target.result;
      const stores = [
        {name:'dailyLogs',key:{keyPath:'date'}},
        {name:'studyBlocks',key:{autoIncrement:true,keyPath:'id'}},
        {name:'metrics',key:{keyPath:'metricName'}},
        {name:'habits',key:{autoIncrement:true,keyPath:'id'}},
        {name:'streaks',key:{keyPath:'type'}},
        {name:'performanceHistory',key:{autoIncrement:true,keyPath:'id'}},
        {name:'mission',key:{keyPath:'id'}},
        {name:'themes',key:{keyPath:'id'}},
        {name:'interruptions',key:{autoIncrement:true,keyPath:'id'}},
        {name:'fatigueHistory',key:{autoIncrement:true,keyPath:'id'}},
      ];
      stores.forEach(s => { if (!d.objectStoreNames.contains(s.name)) d.createObjectStore(s.name,s.key); });
    };
    req.onsuccess = e => { db = e.target.result; res(db); };
    req.onerror = rej;
  });
}
const tx = (store,mode='readonly') => db.transaction(store,mode).objectStore(store);
function dbGet(store,key) { return new Promise((res,rej) => { const r=tx(store).get(key); r.onsuccess=e=>res(e.target.result); r.onerror=rej; }); }
function dbPut(store,val) { return new Promise((res,rej) => { const r=tx(store,'readwrite').put(val); r.onsuccess=e=>res(e.target.result); r.onerror=rej; }); }
function dbAdd(store,val) { return new Promise((res,rej) => { const r=tx(store,'readwrite').add(val); r.onsuccess=e=>res(e.target.result); r.onerror=rej; }); }
function dbDelete(store,key) { return new Promise((res,rej) => { const r=tx(store,'readwrite').delete(key); r.onsuccess=e=>res(e.target.result); r.onerror=rej; }); }
function dbGetAll(store) { return new Promise((res,rej) => { const r=tx(store).getAll(); r.onsuccess=e=>res(e.target.result); r.onerror=rej; }); }
function dbClear(store) { return new Promise((res,rej) => { const r=tx(store,'readwrite').clear(); r.onsuccess=()=>res(); r.onerror=rej; }); }

// ================================================================
// STATE
// ================================================================
const state = {
  metrics: { Focus:50, Discipline:50, Momentum:50, Execution:0 },
  blocks: [], habits: [], streaks:{study:0,deepWork:0},
  mission: null, theme:'obsidian', todayLog:null, fatigueIndex:null,
  currentView:'dashboard', calDate:new Date(), calView:'month',
  dayView:new Date(), weekOffset:0, runningTimers:{},
  dragBlockId:null, rank:'IRON', lastBackup:null, addingForDate:null,
  reportRange:null, reportQuick:null,
};

// ================================================================
// HELPERS
// ================================================================
const today = () => new Date().toISOString().split('T')[0];
const pad2 = n => String(n).padStart(2,'0');
const fmtTime = s => `${pad2(Math.floor(s/3600))}:${pad2(Math.floor((s%3600)/60))}:${pad2(s%60)}`;
const fmtHr = s => (s/3600).toFixed(2)+'h';
const dayNames = ['SUN','MON','TUE','WED','THU','FRI','SAT'];
const monthNames = ['January','February','March','April','May','June','July','August','September','October','November','December'];
const addDays = (d,n) => { const r=new Date(d); r.setDate(r.getDate()+n); return r; };
const dateStr = d => d.toISOString().split('T')[0];
const parseDate = s => new Date(s+'T12:00:00');

function el(id) { return document.getElementById(id); }
function setText(id,v) { const e=el(id); if(e) e.textContent=v; }

// ================================================================
// METRICS ENGINE
// ================================================================
async function loadMetrics() {
  const keys = ['Focus','Discipline','Momentum','Execution'];
  for (const k of keys) {
    const r = await dbGet('metrics',k);
    // CLEAN START: default is 50, not 75
    state.metrics[k] = r ? r.value : 50;
  }
}
async function saveMetric(name,value) {
  value = Math.max(0,Math.min(100,Math.round(value)));
  state.metrics[name] = value;
  await dbPut('metrics',{metricName:name,value});
  updateMetricUI(name,value);
}
async function adjustMetric(name,delta) {
  await saveMetric(name, state.metrics[name]+delta);
}
function updateMetricUI(name,value) {
  const ring = el('ring-'+name);
  const v = el('val-'+name);
  if (!ring||!v) return;
  const circ = 2*Math.PI*32;
  ring.style.strokeDashoffset = circ-(value/100)*circ;
  v.textContent = value;
  ring.style.stroke = value>=80?'var(--success)':value>=60?'var(--accent)':value>=40?'var(--warn)':'var(--danger)';
}
function renderAllMetrics() { Object.keys(state.metrics).forEach(k=>updateMetricUI(k,state.metrics[k])); }

// ================================================================
// STUDY BLOCKS ENGINE
// ================================================================
async function loadBlocks() { state.blocks = await dbGetAll('studyBlocks'); }

function openAddBlock() {
  state.addingForDate = null;
  el('editBlockId').value=''; el('blockSubject').value=''; el('blockDuration').value='';
  el('blockStartTime').value=''; el('blockTests').value='0'; el('blockCompletedTests').value='0';
  el('blockDate').value=today(); el('blockModalTitle').textContent='ADD STUDY BLOCK';
  openModal('addBlockModal');
}
function openAddBlockForDate() {
  openAddBlock();
  el('blockDate').value = dateStr(state.dayView);
}
async function saveBlock() {
  const id = el('editBlockId').value;
  const subject = el('blockSubject').value.trim();
  const blockObject = el('blockObject').value.trim();
  const duration = parseInt(el('blockDuration').value)||60;
  const startTime = el('blockStartTime').value;
  const tests = parseInt(el('blockTests').value)||0;
  const completedTests = parseInt(el('blockCompletedTests').value)||0;
  const date = el('blockDate').value||today();
  if (!subject) { showToast('Enter a subject name'); return; }
  const subjectCategory = classifySubject(subject); // classify from subject only, never from object
  const block = {subject,blockObject,subjectCategory,duration,startTime,tests,completedTests,date,status:'idle',elapsed:0,actualStart:null};
  if (id) {
    const ex = state.blocks.find(b=>b.id==id);
    if (ex) { Object.assign(ex,block); ex.id=parseInt(id); await dbPut('studyBlocks',ex); }
  } else {
    block.id = await dbAdd('studyBlocks',block);
    state.blocks.push(block);
  }
  closeModal('addBlockModal');
  renderBlocks();
  renderCalendar();
  await calculateTodayExecution();
}
async function deleteBlock(id) {
  await dbDelete('studyBlocks',id);
  state.blocks = state.blocks.filter(b=>b.id!==id);
  if (state.runningTimers[id]) { clearInterval(state.runningTimers[id].interval); delete state.runningTimers[id]; }
  renderBlocks(); renderCalendar();
  await calculateTodayExecution();
}
function editBlock(id) {
  const b = state.blocks.find(x=>x.id===id);
  if (!b) return;
  el('editBlockId').value=id; el('blockSubject').value=b.subject;
  el('blockObject').value=b.blockObject||'';
  el('blockDuration').value=b.duration;
  el('blockStartTime').value=b.startTime||''; el('blockTests').value=b.tests||0;
  el('blockCompletedTests').value=b.completedTests||0; el('blockDate').value=b.date||today();
  el('blockModalTitle').textContent='EDIT STUDY BLOCK';
  openModal('addBlockModal');
}
async function updateCompletedTests(id,val) {
  const b = state.blocks.find(x=>x.id===id);
  if (!b) return;
  b.completedTests = parseInt(val)||0;
  await dbPut('studyBlocks',b);
  await calculateTodayExecution();
}

// ================================================================
// TIMER ENGINE
// ================================================================
function startBlock(id) {
  const block = state.blocks.find(b=>b.id===id);
  if (!block||block.status==='completed') return;
  if (block.startTime) {
    const now=new Date(), [h,m]=block.startTime.split(':').map(Number);
    const planned=new Date(); planned.setHours(h,m,0,0);
    const diff=(now-planned)/60000;
    if (diff>60) { adjustMetric('Momentum',-3); showToast('Late 60+ min — Momentum -3'); }
    else if (diff>30) { adjustMetric('Discipline',-5); showToast('Late 30+ min — Discipline -5'); }
    else if (diff>15) { adjustMetric('Discipline',-2); showToast('Late 15+ min — Discipline -2'); }
  }
  block.status='running'; block.actualStart=block.actualStart||Date.now();
  dbPut('studyBlocks',block);
  if (!state.runningTimers[id]) state.runningTimers[id]={elapsed:block.elapsed||0};
  state.runningTimers[id].startedAt=Date.now();
  state.runningTimers[id].interval=setInterval(()=>{
    const t=state.runningTimers[id];
    t.elapsed=(block.elapsed||0)+Math.floor((Date.now()-t.startedAt)/1000);
    const te=el('timer-'+id); if(te) te.textContent=fmtTime(t.elapsed);
    const pe=el('prog-'+id); if(pe) pe.style.width=Math.min(100,(t.elapsed/(block.duration*60))*100)+'%';
    calculateTodayExecution();
  },1000);
  renderBlocks();
}
function pauseBlock(id) {
  const block=state.blocks.find(b=>b.id===id);
  if (!block||block.status!=='running') return;
  const t=state.runningTimers[id];
  if (t) { clearInterval(t.interval); block.elapsed=t.elapsed; }
  block.status='paused';
  dbPut('studyBlocks',block);
  adjustMetric('Focus',-2);
  logInterruption(id,'manual pause');
  renderBlocks();
  showToast('Block paused — Focus -2');
}
async function completeBlock(id) {
  const block=state.blocks.find(b=>b.id===id);
  if (!block) return;
  const t=state.runningTimers[id];
  if (t) { clearInterval(t.interval); block.elapsed=t.elapsed; delete state.runningTimers[id]; }
  block.status='completed';
  await dbPut('studyBlocks',block);
  renderBlocks();
  await calculateTodayExecution();
  await updateStreaks(); await updateRank();
  renderDashboard();
  showToast(`Block complete: ${block.subject}`);
}
async function logInterruption(blockId,reason) {
  await dbAdd('interruptions',{blockId,reason,timestamp:Date.now(),date:today()});
}
document.addEventListener('visibilitychange',()=>{
  if (document.hidden) {
    Object.keys(state.runningTimers).forEach(id=>{
      const b=state.blocks.find(b=>b.id==id);
      if (b&&b.status==='running') { pauseBlock(parseInt(id)); showToast('Auto-paused: tab hidden — Focus -2'); }
    });
  }
});

// ================================================================
// RENDER BLOCKS
// ================================================================
function renderBlocks(container) {
  const el2=container||el('blocksList');
  if (!el2) return;
  const dateFilter=container?null:today();
  const blocks=dateFilter?state.blocks.filter(b=>b.date===dateFilter):state.blocks;
  if (!blocks.length) {
    el2.innerHTML='<div class="no-data-inline">No blocks for today. Use the button above to add your first study session.</div>';
    return;
  }
  el2.innerHTML=blocks.map(b=>blockHTML(b)).join('');
  el2.querySelectorAll('.block-card[draggable]').forEach(card=>{
    card.addEventListener('dragstart',e=>{state.dragBlockId=parseInt(card.dataset.id);e.dataTransfer.effectAllowed='move';});
    card.addEventListener('dragover',e=>{e.preventDefault();card.classList.add('drag-over');});
    card.addEventListener('dragleave',()=>card.classList.remove('drag-over'));
    card.addEventListener('drop',e=>{e.preventDefault();card.classList.remove('drag-over');swapBlocks(state.dragBlockId,parseInt(card.dataset.id));});
  });
}
function blockHTML(b) {
  const elapsed=(state.runningTimers[b.id]&&state.runningTimers[b.id].elapsed)||b.elapsed||0;
  const pct=Math.min(100,(elapsed/(b.duration*60))*100);
  const sc=b.status==='running'?'running':b.status==='paused'?'paused':b.status==='completed'?'done':'idle';
  const cc=b.status==='completed'?'completed':b.status==='running'?'running':b.status==='paused'?'paused':'';
  const eff=elapsed>0?(b.completedTests/(elapsed/3600)).toFixed(1):null;
  const cat=b.subjectCategory||classifySubject(b.subject);
  const catColor=subjectCatColor(cat);
  const objRTL=b.blockObject&&isRTL(b.blockObject);
  return `<div class="block-card ${cc}" draggable="true" data-id="${b.id}">
    <div class="block-header">
      <div class="block-subject">${b.subject}<span class="subject-cat-badge" style="background:${catColor}22;color:${catColor};border-color:${catColor}44">${cat}</span></div>
      <span class="status-badge ${sc}">${b.status.toUpperCase()}</span>
    </div>
    ${b.blockObject?`<div class="block-object ${objRTL?'':'ltr'}">${b.blockObject}</div>`:''}
    <div class="block-meta">
      <span>⏱ ${b.duration}m</span>
      ${b.startTime?`<span>🕐 ${b.startTime}</span>`:''}
      <span>📋 ${b.completedTests||0}/${b.tests} tests</span>
      <span>📅 ${b.date}</span>
      ${eff!==null?`<span class="test-efficiency-badge">${eff} t/hr</span>`:''}
    </div>
    <div class="block-timer" id="timer-${b.id}">${fmtTime(elapsed)}</div>
    <div class="block-controls">
      ${b.status!=='completed'&&b.status!=='running'?`<button class="btn btn-primary btn-sm" onclick="startBlock(${b.id})">START</button>`:''}
      ${b.status==='running'?`<button class="btn btn-sm" onclick="pauseBlock(${b.id})">PAUSE</button>`:''}
      ${b.status!=='completed'?`<button class="btn btn-sm" onclick="completeBlock(${b.id})">COMPLETE</button>`:''}
      <button class="btn btn-sm" onclick="editBlock(${b.id})">EDIT</button>
      <button class="btn btn-danger btn-sm" onclick="deleteBlock(${b.id})">✕</button>
    </div>
    <div class="test-log-row">
      <span class="test-log-label">TESTS DONE:</span>
      <input class="test-log-input" type="number" min="0" value="${b.completedTests||0}" onchange="updateCompletedTests(${b.id},this.value)" placeholder="0">
      <span style="font-size:10px;color:var(--text3);font-family:var(--font-mono)">/ ${b.tests} target</span>
    </div>
    <div class="block-progress"><div class="block-progress-fill" id="prog-${b.id}" style="width:${pct}%"></div></div>
  </div>`;
}
function swapBlocks(id1,id2) {
  if (id1===id2) return;
  const b1=state.blocks.find(b=>b.id===id1),b2=state.blocks.find(b=>b.id===id2);
  if (!b1||!b2) return;
  [b1.date,b2.date]=[b2.date,b1.date];
  [b1.startTime,b2.startTime]=[b2.startTime,b1.startTime];
  dbPut('studyBlocks',b1); dbPut('studyBlocks',b2);
  renderBlocks(); renderCalendar();
}

// ================================================================
// EXECUTION CALCULATION — UPDATED FORMULA
// Study Hours ×0.4 + Block Completion ×0.2 + Test Volume ×0.4
// ================================================================
async function calculateTodayExecution() {
  const todayBlocks = state.blocks.filter(b=>b.date===today());
  const todayLog = state.todayLog||{date:today(),plannedHours:0,dailyTestTarget:0};
  const plannedSec = (todayLog.plannedHours||0)*3600;
  const plannedTests = todayLog.dailyTestTarget||0;

  let completedSec=0;
  todayBlocks.forEach(b=>{
    const e=(state.runningTimers[b.id]&&state.runningTimers[b.id].elapsed)||b.elapsed||0;
    completedSec+=e;
  });
  const completedBlocks=todayBlocks.filter(b=>b.status==='completed').length;
  const totalBlocks=Math.max(1,todayBlocks.length);
  const totalCompletedTests=todayBlocks.reduce((s,b)=>s+(b.completedTests||0),0);
  const totalTargetTests=Math.max(1,todayBlocks.reduce((s,b)=>s+(b.tests||0),0));

  // New dual-weighted formula
  const hourScore = plannedSec>0?Math.min(1,completedSec/plannedSec):0;
  const blockScore = completedBlocks/totalBlocks;
  const testScore = plannedTests>0?Math.min(1,totalCompletedTests/plannedTests):Math.min(1,totalCompletedTests/totalTargetTests);
  const weighted = (hourScore*0.4 + blockScore*0.2 + testScore*0.4)*100;

  await saveMetric('Execution',Math.round(weighted));

  // Test efficiency
  const effVal = completedSec>0?(totalCompletedTests/(completedSec/3600)).toFixed(1):null;

  // UI updates
  setText('execScoreBig',Math.round(weighted)+'%');
  const pb=el('execProgressBar'); if(pb) pb.style.width=weighted+'%';
  setText('dash-completed',fmtHr(completedSec));
  setText('dash-planned',(todayLog.plannedHours||0)+'h');
  setText('dash-tests',totalCompletedTests);
  setText('dash-testsTarget',plannedTests||totalTargetTests);
  setText('dash-hoursTotal',fmtHr(completedSec));
  setText('dash-testsTotal',totalCompletedTests);

  // Efficiency
  const effEl=el('testEfficiencyVal');
  const effBar=el('testEfficiencyBar');
  const effRating=el('testEfficiencyRating');
  if (effEl) {
    if (effVal!==null) {
      effEl.textContent=effVal;
      const ef=parseFloat(effVal);
      if(effBar) effBar.style.width=Math.min(100,ef*5)+'%';
      if(effRating) effRating.textContent=ef>=15?'EXCELLENT':ef>=10?'STRONG':ef>=5?'MODERATE':ef>0?'LOW':'—';
    } else { effEl.textContent='—'; if(effRating) effRating.textContent='no data'; }
  }

  // Save log
  const log={date:today(),plannedHours:todayLog.plannedHours||0,dailyTestTarget:todayLog.dailyTestTarget||0,
    completedSec,completedBlocks,totalTests:totalCompletedTests,execPct:Math.round(weighted)};
  await dbPut('dailyLogs',log);
  state.todayLog=log;

  updateMissionPressure();
  checkCommandMode();
  calculateFatigue();
  return Math.round(weighted);
}

// ================================================================
// MISSION PRESSURE ENGINE
// ================================================================
async function loadMission() {
  const m=await dbGet('mission','primary');
  state.mission=m||null;
}
async function saveMission() {
  const date=el('missionDate').value;
  const hours=parseFloat(el('missionHours').value)||0;
  const testsReq=parseInt(el('missionTestsRequired').value)||0;
  const name=el('missionName').value.trim();
  if (!date||!hours) { showToast('Set target date and required hours'); return; }
  state.mission={id:'primary',targetDate:date,requiredHours:hours,requiredTests:testsReq,name};
  await dbPut('mission',state.mission);
  updateMissionPressure();
  showToast('Mission locked in: '+name);
}
async function updateMissionPressure() {
  const m=state.mission;
  const countdown=el('missionCountdown');
  if (!m) {
    if(countdown) { countdown.textContent='NO MISSION'; countdown.className='tpi-green'; }
    el('missionNoData').style.display='';
    el('missionActivePanel').style.display='none';
    return;
  }
  el('missionNoData').style.display='none';
  el('missionActivePanel').style.display='';

  const now=new Date(), target=new Date(m.targetDate);
  const daysLeft=Math.max(0,Math.ceil((target-now)/86400000));
  const logs=await dbGetAll('dailyLogs');
  const totalCompSec=logs.reduce((s,l)=>s+(l.completedSec||0),0);
  const totalCompTests=logs.reduce((s,l)=>s+(l.totalTests||0),0);
  const completedHrs=totalCompSec/3600;
  const remainHrs=Math.max(0,m.requiredHours-completedHrs);
  const remainTests=Math.max(0,(m.requiredTests||0)-totalCompTests);

  const recent7=logs.slice(-7);
  const avgSec=recent7.length?recent7.reduce((s,l)=>s+(l.completedSec||0),0)/recent7.length:3600*3;
  const capacity=Math.max(0.5,avgSec/3600);
  const tpi=daysLeft>0?remainHrs/(daysLeft*capacity):99;

  let cls='tpi-green';
  if(tpi>1.2) cls='tpi-red';
  else if(tpi>1.0) cls='tpi-orange';
  else if(tpi>0.8) cls='tpi-yellow';
  if(countdown) { countdown.className=cls; countdown.textContent=`${daysLeft}d · ${remainHrs.toFixed(0)}h · TPI ${tpi.toFixed(2)}`; }
  setText('headerRank',state.rank);

  const statsEl=el('missionStats');
  if(statsEl) statsEl.innerHTML=`
    <div class="tpi-stat"><div class="tpi-val">${daysLeft}</div><div class="tpi-label">Days Left</div></div>
    <div class="tpi-stat"><div class="tpi-val">${remainHrs.toFixed(0)}h</div><div class="tpi-label">Hours Left</div></div>
    <div class="tpi-stat"><div class="tpi-val">${capacity.toFixed(1)}h</div><div class="tpi-label">Daily Cap.</div></div>`;
  setText('missionHoursLeft',remainHrs.toFixed(0)+'h');
  setText('missionTestsLeft',remainTests>0?remainTests:'N/A');

  const tpiV=el('tpiVal'),tpiB=el('tpiBar');
  if(tpiV) { tpiV.textContent=tpi.toFixed(2); tpiV.style.color=tpi>1.2?'var(--danger)':tpi>1?'#ff7700':tpi>0.8?'var(--warn)':'var(--success)'; }
  if(tpiB) { tpiB.style.width=Math.min(100,tpi*60)+'%'; tpiB.style.background=tpi>1.2?'var(--danger)':tpi>1?'#ff7700':tpi>0.8?'var(--warn)':'var(--success)'; }

  const aEl=el('missionAdvisor');
  if(aEl) {
    aEl.style.display='block';
    const needed=daysLeft>0?remainHrs/daysLeft:remainHrs;
    let msg='',cls2='';
    if(tpi>1.2){msg=`CRITICAL. You need ${needed.toFixed(1)}h/day vs ${capacity.toFixed(1)}h realistic capacity. Immediate load increase required.`;cls2='critical';}
    else if(tpi>1.0){msg=`UNDER PRESSURE. Target ${needed.toFixed(1)}h/day. Current capacity: ${capacity.toFixed(1)}h. Marginal deficit.`;cls2='warn';}
    else if(tpi>0.8){msg=`MANAGEABLE. ${needed.toFixed(1)}h/day required. Maintain pace and avoid disruptions.`;cls2='warn';}
    else{msg=`ON TRACK. Pace exceeds requirement by ${(capacity-needed).toFixed(1)}h/day buffer.`;cls2='positive';}
    aEl.textContent=msg; aEl.className='advisor-msg mt-12 '+cls2;
  }

  // Populate form if empty
  if(el('missionDate')&&!el('missionDate').value) el('missionDate').value=m.targetDate;
  if(el('missionHours')&&!el('missionHours').value) el('missionHours').value=m.requiredHours;
  if(el('missionTestsRequired')&&!el('missionTestsRequired').value) el('missionTestsRequired').value=m.requiredTests||'';
  if(el('missionName')&&!el('missionName').value) el('missionName').value=m.name||'';
}

// ================================================================
// COMMAND MODE
// ================================================================
async function checkCommandMode() {
  const logs=await dbGetAll('dailyLogs');
  const r3=logs.slice(-3);
  const allLow=r3.length>=3&&r3.every(l=>l.execPct<80);
  const tpiHigh=el('missionCountdown')&&el('missionCountdown').className.includes('tpi-red');
  const banner=el('commandBanner');
  if(allLow&&tpiHigh){banner.classList.add('active');document.body.classList.add('command-mode');}
  else{banner.classList.remove('active');document.body.classList.remove('command-mode');}
  if(!allLow&&r3.length>=3&&r3.every(l=>l.execPct>=80)){
    document.body.classList.add('performance-glow');
    setTimeout(()=>document.body.classList.remove('performance-glow'),2000);
  }
}

// ================================================================
// FATIGUE INTELLIGENCE ENGINE — Extended with test density
// ================================================================
async function calculateFatigue() {
  const logs=await dbGetAll('dailyLogs');
  const todayBlocks=state.blocks.filter(b=>b.date===today());
  const ints=await dbGetAll('interruptions');
  const todayInts=ints.filter(i=>i.date===today()).length;
  const hoursToday=(logs.find(l=>l.date===today())?.completedSec||0)/3600;
  const testsToday=todayBlocks.reduce((s,b)=>s+(b.completedTests||0),0);
  const lateNight=todayBlocks.filter(b=>b.startTime&&parseInt(b.startTime.split(':')[0])>=21).length;
  const r3=logs.slice(-3);
  const consHigh=r3.filter(l=>l.execPct>=85).length;
  // Test density factor: more than 20 tests/hr is high mental load
  const testDensity=hoursToday>0?testsToday/hoursToday:0;
  let fatigue=100;
  fatigue-=hoursToday*4;
  fatigue-=lateNight*8;
  fatigue-=todayInts*3;
  fatigue-=consHigh*5;
  fatigue-=Math.max(0,(testDensity-10)*2); // penalty for very high test density
  fatigue=Math.max(0,Math.min(100,Math.round(fatigue)));
  state.fatigueIndex=fatigue;
  const bar=el('fatigueBar'),v=el('fatigueVal'),lbl=el('fatigueLabel'),adv=el('fatigueAdvice');
  if(!bar) return;
  bar.style.width=fatigue+'%';
  let col,ltext,atext;
  if(fatigue>=60){col='var(--success)';ltext='STABLE';atext='Cognitive reserves adequate. Maintain current rhythm.';}
  else if(fatigue>=40){col='var(--warn)';ltext='ELEVATED';atext='Fatigue accumulating. Consider reducing late-night sessions.';}
  else if(fatigue>=25){col='#ff7700';ltext='WARNING';atext='Warning threshold reached. A strategic rest block is advisable.';}
  else if(fatigue>=15){col='var(--danger)';ltext='BURNOUT RISK';atext='Burnout risk active. Quality of output is degrading. Rest is a tactical decision.';}
  else{col='#ff0055';ltext='CRITICAL';atext='Critical cognitive depletion. Mandatory rest. Performance is severely impaired.';}
  bar.style.background=col;
  if(lbl){lbl.textContent=ltext;lbl.style.color=col;}
  if(v) v.textContent=fatigue;
  if(adv) adv.textContent=atext;
  await dbAdd('fatigueHistory',{date:today(),fatigue,timestamp:Date.now()});
}

// ================================================================
// STREAK ENGINE
// ================================================================
async function updateStreaks() {
  const logs=(await dbGetAll('dailyLogs')).sort((a,b)=>b.date.localeCompare(a.date));
  let study=0;
  for(const l of logs){if(l.execPct>=85) study++; else break;}
  const doneToday=state.blocks.filter(b=>b.date===today()&&b.status==='completed').length;
  let dw=(await dbGet('streaks','deepWork'))?.count||0;
  if(doneToday>=4) dw++; else dw=0;
  state.streaks.study=study; state.streaks.deepWork=dw;
  await dbPut('streaks',{type:'study',count:study});
  await dbPut('streaks',{type:'deepWork',count:dw});
  setText('studyStreakVal',study); setText('deepWorkStreakVal',dw);
}

// ================================================================
// RANK ENGINE
// ================================================================
async function updateRank() {
  const logs=await dbGetAll('dailyLogs');
  const week=logs.slice(-7);
  const avgExec=week.length?week.reduce((s,l)=>s+(l.execPct||0),0)/week.length:0;
  const score=avgExec*0.5+state.metrics.Momentum*0.3+Math.min(100,state.streaks.study*10)*0.2;
  let rank,icon;
  if(score>=90){rank='ELITE';icon='⭐';}
  else if(score>=75){rank='GOLD';icon='🔶';}
  else if(score>=60){rank='SILVER';icon='⬡';}
  else if(score>=40){rank='BRONZE';icon='▲';}
  else{rank='IRON';icon='⚙';}
  state.rank=rank;
  setText('rankIcon',icon); setText('rankName',rank);
  setText('rankScore',week.length?`Score: ${Math.round(score)} · ${week.length}-day basis`:'Log activity to receive ranking');
  setText('headerRank',rank);
}

// ================================================================
// HABITS ENGINE
// ================================================================
async function loadHabits() { state.habits=await dbGetAll('habits'); }
function openAddHabit() { el('habitName').value=''; el('habitPenalty').value='3'; openModal('addHabitModal'); }
async function saveHabit() {
  const name=el('habitName').value.trim();
  const penalty=parseInt(el('habitPenalty').value)||3;
  if(!name){showToast('Enter habit name');return;}
  const h={name,penalty};
  h.id=await dbAdd('habits',h);
  state.habits.push(h);
  closeModal('addHabitModal'); renderHabits();
}
async function deleteHabit(id) { await dbDelete('habits',id); state.habits=state.habits.filter(h=>h.id!==id); renderHabits(); }
async function logHabit(id,avoided) {
  const h=state.habits.find(x=>x.id===id);
  if(!h) return;
  if(avoided){await adjustMetric('Discipline',2);await adjustMetric('Momentum',1);showToast(`Avoided "${h.name}" — Discipline +2, Momentum +1`);}
  else{await adjustMetric('Focus',-h.penalty);await adjustMetric('Momentum',-h.penalty);showToast(`Performed "${h.name}" — Focus -${h.penalty}, Momentum -${h.penalty}`);}
  renderAllMetrics();
}
function renderHabits() {
  const listEl=el('habitsList'),dayEl=el('habitDailyLog');
  if(!listEl) return;
  if(!state.habits.length){
    listEl.innerHTML='<div class="no-data-inline">No habits tracked. Add your first habit to begin monitoring behavioral compliance.</div>';
    if(dayEl) dayEl.innerHTML='<div class="text-muted">Add habits above to track them daily.</div>';
    return;
  }
  listEl.innerHTML=state.habits.map(h=>`<div class="habit-item">
    <div><div class="habit-name">${h.name}</div><div class="habit-penalty">Penalty: -${h.penalty}</div></div>
    <button class="btn btn-danger btn-sm" onclick="deleteHabit(${h.id})">REMOVE</button>
  </div>`).join('');
  if(dayEl) dayEl.innerHTML=state.habits.map(h=>`<div class="habit-item">
    <div class="habit-name">${h.name}</div>
    <div class="habit-controls">
      <button class="btn btn-sm" onclick="logHabit(${h.id},true)" style="border-color:var(--success);color:var(--success)">AVOIDED ✓</button>
      <button class="btn btn-danger btn-sm" onclick="logHabit(${h.id},false)">PERFORMED ✗</button>
    </div>
  </div>`).join('');
}

// ================================================================
// CALENDAR ENGINE
// ================================================================
function renderCalendar() {
  const cv=state.calView;
  el('calView-month').classList.toggle('hidden',cv!=='month');
  el('calView-week').classList.toggle('hidden',cv!=='week');
  el('calView-day').classList.toggle('hidden',cv!=='day');
  el('calViewMonth').classList.toggle('btn-active',cv==='month');
  el('calViewWeek').classList.toggle('btn-active',cv==='week');
  el('calViewDay').classList.toggle('btn-active',cv==='day');
  if(cv==='month') renderMonthView();
  else if(cv==='week') renderWeekView();
  else renderDayView();
}
function setCalView(v){state.calView=v;renderCalendar();}
function renderMonthView() {
  const d=state.calDate,y=d.getFullYear(),m=d.getMonth();
  setText('calMonthTitle',`${monthNames[m]} ${y}`);
  const grid=el('calGrid');
  let html=dayNames.map(n=>`<div class="cal-dayname">${n}</div>`).join('');
  const first=new Date(y,m,1),last=new Date(y,m+1,0),pad=first.getDay(),todayS=today();
  for(let i=0;i<pad;i++){const pd=new Date(y,m,-pad+i+1);html+=`<div class="cal-cell other-month"><div class="cal-date">${pd.getDate()}</div></div>`;}
  for(let day=1;day<=last.getDate();day++){
    const ds=`${y}-${pad2(m+1)}-${pad2(day)}`;
    const db=state.blocks.filter(b=>b.date===ds);
    const isT=ds===todayS;
    const ep=db.length?Math.round(db.filter(b=>b.status==='completed').length/db.length*100):0;
    const ec=ep>=85?'var(--success)':ep>=60?'var(--warn)':ep>0?'var(--danger)':'var(--border2)';
    html+=`<div class="cal-cell${isT?' today':''}" onclick="openDayFromCal('${ds}')">
      <div class="cal-date">${day}</div>
      ${db.slice(0,2).map(b=>`<div class="cal-block-dot">• ${b.subject}</div>`).join('')}
      ${db.length>2?`<div class="cal-block-dot">+${db.length-2}</div>`:''}
      ${db.length?`<div class="cal-exec-bar"><div class="cal-exec-fill" style="width:${ep}%;background:${ec}"></div></div>`:''}
    </div>`;
  }
  const ep2=(7-(pad+last.getDate())%7)%7;
  for(let i=1;i<=ep2;i++) html+=`<div class="cal-cell other-month"><div class="cal-date">${i}</div></div>`;
  grid.innerHTML=html;
}
function calNav(dir){const d=state.calDate;state.calDate=new Date(d.getFullYear(),d.getMonth()+dir,1);renderCalendar();}
function openDayFromCal(ds){state.dayView=parseDate(ds);state.calView='day';renderCalendar();}
function renderWeekView() {
  const now=new Date(),ws=new Date(now);
  ws.setDate(now.getDate()-now.getDay()+state.weekOffset*7);
  const days=Array.from({length:7},(_,i)=>{const d=new Date(ws);d.setDate(ws.getDate()+i);return d;});
  const todayS=today();
  setText('calWeekTitle',`Week of ${monthNames[ws.getMonth()]} ${ws.getDate()}, ${ws.getFullYear()}`);
  let html='<div class="week-time"></div>'+days.map(d=>{const ds=dateStr(d);const it=ds===todayS;return`<div class="week-dayhead${it?' today-col':''}">${dayNames[d.getDay()]}<br>${d.getDate()}</div>`;}).join('');
  for(let h=0;h<24;h++){
    html+=`<div class="week-time">${pad2(h)}:00</div>`;
    days.forEach(d=>{
      const ds=dateStr(d);
      const bh=state.blocks.filter(b=>b.date===ds&&b.startTime&&parseInt(b.startTime.split(':')[0])===h);
      html+=`<div class="week-cell" onclick="openDayFromCal('${ds}')">
        ${bh.map(b=>`<div class="week-block-item">${b.subject}</div>`).join('')}
      </div>`;
    });
  }
  el('weekGrid').innerHTML=html;
  el('weekGrid').style.gridTemplateColumns='50px repeat(7,1fr)';
}
function weekNav(dir){state.weekOffset+=dir;renderCalendar();}
function renderDayView() {
  const ds=dateStr(state.dayView);
  setText('calDayTitle',`${dayNames[state.dayView.getDay()]}, ${monthNames[state.dayView.getMonth()]} ${state.dayView.getDate()}, ${state.dayView.getFullYear()}`);
  const db=state.blocks.filter(b=>b.date===ds);
  const comp=db.filter(b=>b.status==='completed').length;
  const cSec=db.reduce((s,b)=>s+(b.elapsed||0),0);
  const tests=db.reduce((s,b)=>s+(b.completedTests||0),0);
  const ep=db.length?Math.round(comp/db.length*100):0;
  const ph=db.reduce((s,b)=>s+b.duration/60,0);
  const statsEl=el('dayPanelStats');
  if(statsEl) statsEl.innerHTML=`
    <div class="tpi-stat"><div class="tpi-val">${ph.toFixed(1)}h</div><div class="tpi-label">Planned</div></div>
    <div class="tpi-stat"><div class="tpi-val">${fmtHr(cSec)}</div><div class="tpi-label">Completed</div></div>
    <div class="tpi-stat"><div class="tpi-val">${tests}</div><div class="tpi-label">Tests</div></div>
    <div class="tpi-stat"><div class="tpi-val">${ep}%</div><div class="tpi-label">Execution</div></div>
    <div class="tpi-stat"><div class="tpi-val">${comp}/${db.length}</div><div class="tpi-label">Blocks</div></div>
    <div class="tpi-stat"><div class="tpi-val">${ph>=10?'HEAVY':ph>=6?'BALANCED':ph>=3?'MODERATE':'LIGHT'}</div><div class="tpi-label">Load</div></div>`;
  const rating=getTacticalRating(db,ep);
  const rEl=el('dayTacticalRating');
  if(rEl){rEl.textContent=rating.msg;rEl.className='advisor-msg mt-8 '+rating.type;}
  const dl=el('dayBlocksList');
  if(dl) renderBlocks(dl);
}
function dayNav(dir){state.dayView=addDays(state.dayView,dir);renderCalendar();}
function getTacticalRating(blocks,ep) {
  const hrs=blocks.reduce((s,b)=>s+b.duration/60,0);
  const fi=state.fatigueIndex;
  if(hrs>12) return{type:'critical',msg:'OVERLOADED: Volume exceeds sustainable cognitive capacity. Redistribute blocks.'};
  if(fi!==null&&fi<25&&hrs>6) return{type:'warn',msg:'WARNING: Heavy load combined with critical fatigue. Output quality severely compromised.'};
  if(hrs>8) return{type:'warn',msg:'HEAVY: Approaching upper cognitive load threshold. Monitor execution closely.'};
  if(ep<60&&blocks.length>0) return{type:'warn',msg:'UNDERPERFORMING: Execution below 60%. Diagnose the friction—environmental or scheduling issue.'};
  if(hrs<3) return{type:'warn',msg:'UNDERLOADED: Low planned volume. Review mission requirements and adjust targets.'};
  return{type:'positive',msg:'BALANCED: Day structure is sustainable and well-distributed.'};
}

// ================================================================
// PERFORMANCE HISTORY BARS
// ================================================================
async function renderPerfBars() {
  const logs=await dbGetAll('dailyLogs');
  const week=logs.slice(-7);
  const el2=el('perfBars');
  if(!el2) return;
  if(!week.length){el2.innerHTML='<div class="text-muted" style="font-size:10px">Log study sessions to see history</div>';return;}
  el2.innerHTML=week.map(l=>{
    const h=Math.round(l.execPct||0);
    const c=h>=85?'var(--success)':h>=60?'var(--accent)':h>=40?'var(--warn)':'var(--danger)';
    return`<div class="perf-bar-col">
      <div class="perf-bar" style="height:${h*0.5}px;background:${c}"></div>
      <div class="perf-bar-day">${l.date.slice(5)}</div>
    </div>`;
  }).join('');
}

// ================================================================
// ADVISOR ENGINE — Extended with behavioral memory + test/hour balance
// ================================================================
// ================================================================
// AI PATTERN DETECTORS — Advanced behavioral analysis
// ================================================================
function detectWeekdayPatterns(logs) {
  const dayBuckets = {0:[],1:[],2:[],3:[],4:[],5:[],6:[]};
  logs.forEach(l => {
    const d = parseDate(l.date).getDay();
    dayBuckets[d].push(l.execPct || 0);
  });
  const dayAvgs = {};
  Object.keys(dayBuckets).forEach(d => {
    const arr = dayBuckets[d];
    dayAvgs[d] = arr.length >= 2 ? Math.round(arr.reduce((s,v)=>s+v,0)/arr.length) : null;
  });
  const valid = Object.entries(dayAvgs).filter(([,v]) => v !== null);
  if (valid.length < 3) return null;
  const sorted = valid.sort((a,b) => b[1] - a[1]);
  const best = sorted[0];
  const worst = sorted[sorted.length - 1];
  const spread = best[1] - worst[1];
  if (spread < 15) return null;
  return {
    bestDay: dayNames[best[0]],
    bestAvg: best[1],
    worstDay: dayNames[worst[0]],
    worstAvg: worst[1],
    spread,
    allAvgs: dayAvgs
  };
}

function detectExecutionOscillation(logs) {
  if (logs.length < 6) return null;
  const recent = logs.slice(-10);
  let oscillations = 0;
  for (let i = 2; i < recent.length; i++) {
    const prev = recent[i-2].execPct || 0;
    const mid = recent[i-1].execPct || 0;
    const cur = recent[i].execPct || 0;
    if ((mid > prev + 15 && mid > cur + 15) || (mid < prev - 15 && mid < cur - 15)) {
      oscillations++;
    }
  }
  if (oscillations < 2) return null;
  const avgExec = Math.round(recent.reduce((s,l)=>s+(l.execPct||0),0)/recent.length);
  return { oscillations, period: recent.length, avgExec };
}

function detectSubjectEfficiencyTrend(blocks) {
  const last14 = blocks.filter(b => b.date >= dateStr(addDays(new Date(), -14)));
  const first7 = last14.filter(b => b.date < dateStr(addDays(new Date(), -7)));
  const last7 = last14.filter(b => b.date >= dateStr(addDays(new Date(), -7)));
  if (first7.length < 3 || last7.length < 3) return null;
  const catEff = (arr) => {
    const cats = {};
    arr.forEach(b => {
      const cat = b.subjectCategory || classifySubject(b.subject);
      if (!cats[cat]) cats[cat] = { hours: 0, tests: 0 };
      cats[cat].hours += (b.elapsed || 0) / 3600;
      cats[cat].tests += b.completedTests || 0;
    });
    const result = {};
    Object.entries(cats).forEach(([k, v]) => {
      result[k] = v.hours > 0.5 ? v.tests / v.hours : null;
    });
    return result;
  };
  const earlyEff = catEff(first7);
  const lateEff = catEff(last7);
  const trends = [];
  Object.keys(lateEff).forEach(cat => {
    if (earlyEff[cat] !== null && lateEff[cat] !== null) {
      const delta = lateEff[cat] - earlyEff[cat];
      if (Math.abs(delta) > 2) {
        trends.push({ subject: cat, early: earlyEff[cat], late: lateEff[cat], delta });
      }
    }
  });
  return trends.length > 0 ? trends : null;
}

function detectTimeOfDayOptimality(blocks) {
  const completed = blocks.filter(b => b.status === 'completed' && b.startTime && b.elapsed > 0);
  if (completed.length < 5) return null;
  const slots = { morning: { hours: 0, tests: 0, blocks: 0 }, afternoon: { hours: 0, tests: 0, blocks: 0 }, evening: { hours: 0, tests: 0, blocks: 0 }, night: { hours: 0, tests: 0, blocks: 0 } };
  completed.forEach(b => {
    const h = parseInt(b.startTime.split(':')[0]);
    const slot = h < 12 ? 'morning' : h < 17 ? 'afternoon' : h < 21 ? 'evening' : 'night';
    slots[slot].hours += (b.elapsed || 0) / 3600;
    slots[slot].tests += b.completedTests || 0;
    slots[slot].blocks++;
  });
  const efficiencies = {};
  Object.entries(slots).forEach(([k, v]) => {
    efficiencies[k] = v.hours > 0.5 ? { eff: v.tests / v.hours, hours: v.hours, blocks: v.blocks } : null;
  });
  const valid = Object.entries(efficiencies).filter(([, v]) => v !== null);
  if (valid.length < 2) return null;
  valid.sort((a, b) => b[1].eff - a[1].eff);
  return { best: { slot: valid[0][0], ...valid[0][1] }, worst: { slot: valid[valid.length - 1][0], ...valid[valid.length - 1][1] }, all: efficiencies };
}

function detectRecoveryPattern(logs) {
  if (logs.length < 5) return null;
  let badDays = 0, recoveries = 0, collapses = 0;
  for (let i = 1; i < logs.length; i++) {
    const prev = logs[i - 1].execPct || 0;
    const cur = logs[i].execPct || 0;
    if (prev < 60) {
      badDays++;
      if (cur >= 70) recoveries++;
      else collapses++;
    }
  }
  if (badDays < 2) return null;
  return { badDays, recoveries, collapses, recoveryRate: Math.round((recoveries / badDays) * 100) };
}

function detectConsecutiveLoad(logs) {
  if (logs.length < 4) return null;
  const recent = logs.slice(-7);
  let heavyStreak = 0, maxStreak = 0;
  recent.forEach(l => {
    if ((l.plannedHours || 0) >= 8 || (l.completedSec || 0) / 3600 >= 7) {
      heavyStreak++;
      maxStreak = Math.max(maxStreak, heavyStreak);
    } else {
      heavyStreak = 0;
    }
  });
  return maxStreak >= 3 ? { streak: maxStreak } : null;
}
async function generateAdvisory() {
  const logs = (await dbGetAll('dailyLogs')).sort((a,b) => a.date.localeCompare(b.date));
  const ints = await dbGetAll('interruptions');
  const allBlocks = await dbGetAll('studyBlocks');
  const fatHistory = await dbGetAll('fatigueHistory');
  const msgs = [];

  if (logs.length < 3) {
    el('advisoryList').innerHTML = `<div class="advisor-msg warn">
      <span style="font-size:8px;letter-spacing:2px;display:block;margin-bottom:8px;color:var(--text3)">SYSTEM · INSUFFICIENT DATA</span>
      The advisory engine requires a minimum of three logged study days to produce meaningful analysis. At this stage, logging consistently is more important than logging perfectly. Begin with today.
    </div>`;
    return;
  }

  const week = logs.slice(-7);
  const fortnight = logs.slice(-14);
  const allTime = logs;
  const avgExecWeek = week.length ? Math.round(week.reduce((s,l) => s + (l.execPct||0), 0) / week.length) : null;
  const avgExecFort = fortnight.length ? Math.round(fortnight.reduce((s,l) => s + (l.execPct||0), 0) / fortnight.length) : null;
  const avgExecAll = allTime.length ? Math.round(allTime.reduce((s,l) => s + (l.execPct||0), 0) / allTime.length) : null;
  const totalHrsAll = allTime.reduce((s,l) => s + (l.completedSec||0), 0) / 3600;
  const totalTestsAll = allTime.reduce((s,l) => s + (l.totalTests||0), 0);
  const overallEff = totalHrsAll > 0 ? totalTestsAll / totalHrsAll : null;
  const weekHrs = week.reduce((s,l) => s + (l.completedSec||0), 0) / 3600;
  const weekTests = week.reduce((s,l) => s + (l.totalTests||0), 0);

  // ——— 1. SITUATIONAL ASSESSMENT ———
  if (avgExecWeek !== null) {
    if (avgExecWeek >= 90) {
      msgs.push({type:'positive', text:`Your seven-day execution average sits at ${avgExecWeek}%, which places you in the top performance tier. This is not the moment to experiment with your routine — it is the moment to protect it. The systems currently driving this output are working. Your only task is to sustain them without introducing unnecessary friction.`});
    } else if (avgExecWeek >= 75) {
      msgs.push({type:'positive', text:`This week's execution averaged ${avgExecWeek}%. That is a functional performance level, but it falls short of the 85%+ threshold where compounding returns become significant. The gap is narrow enough that it likely stems from one or two specific friction points — a late start, an incomplete block, a session that drifted — rather than a systemic failure. Identify those moments and you close the gap.`});
    } else if (avgExecWeek >= 55) {
      msgs.push({type:'warn', text:`Your recent execution is averaging ${avgExecWeek}%, which sits below the operational threshold. At this level, planned work is consistently not converting into completed output. This is not about motivation — it is about the structural reliability of your daily system. Something in your scheduling, environment, or block design is creating predictable friction. The question is not whether to study harder, but what is repeatedly preventing the study you have already planned from being completed.`});
    } else {
      msgs.push({type:'critical', text:`Weekly execution has dropped to ${avgExecWeek}%. This requires direct acknowledgment: the current approach is not functioning. At sub-55% execution, you are completing barely half of what you set out to do each day. The instinct may be to plan more aggressively to compensate. That instinct is wrong. The priority is to plan less and complete more — reduce your daily block count to what you can realistically finish, then rebuild volume from a foundation of reliability.`});
    }
  }

  // ——— 2. TREND COMPARISON ———
  if (avgExecWeek !== null && avgExecFort !== null && fortnight.length >= 10) {
    const drift = avgExecWeek - avgExecFort;
    if (drift >= 8) {
      msgs.push({type:'positive', text:`There is a meaningful upward trajectory in your execution — this week is tracking ${drift} points above the prior two-week average (${avgExecFort}% → ${avgExecWeek}%). This is worth noting not for congratulation, but because it indicates that something changed in your approach recently, and that change is producing results. Identify what shifted — was it sleep, scheduling, subject selection, or environment? — and deliberately reinforce it.`});
    } else if (drift <= -8) {
      msgs.push({type:'warn', text:`Your execution has declined by ${Math.abs(drift)} points relative to the two-week baseline (${avgExecFort}% → ${avgExecWeek}%). A single off day is noise; a sustained shift of this magnitude is signal. Before attributing this to willpower, examine the structural factors: has your sleep schedule changed? Are blocks being scheduled at realistic times? Is fatigue accumulating from consecutive heavy days? The answer is almost always environmental before it is psychological.`});
    }
  }

  if (avgExecWeek !== null && avgExecAll !== null && allTime.length >= 14) {
    const ltDiff = avgExecWeek - avgExecAll;
    if (Math.abs(ltDiff) >= 12) {
      const dir = ltDiff > 0 ? 'above' : 'below';
      msgs.push({type: ltDiff > 0 ? 'positive' : 'warn', text:`In broader context, this week's ${avgExecWeek}% performance sits ${Math.abs(ltDiff)} points ${dir} your long-term average of ${avgExecAll}%. ${ltDiff > 0 ? 'This suggests genuine improvement rather than a fortunate week — your baseline capacity may be shifting upward.' : 'This divergence from baseline warrants attention. Long-term averages represent your natural operating level; sustained departures indicate either a temporary disruption or an emerging pattern that needs intervention before it becomes the new normal.'}`});
    }
  }

  // ——— 3. OSCILLATION DETECTION ———
  const oscResult = detectExecutionOscillation(logs);
  if (oscResult) {
    msgs.push({type:'warn', text:`A notable oscillation pattern has been detected in your recent execution: ${oscResult.oscillations} significant swings over the last ${oscResult.period} days, with an overall average of ${oscResult.avgExec}%. This alternating high-low pattern — sometimes called the "boom-bust cycle" — is characteristic of inconsistent energy management. You perform intensely on one day, deplete your reserves, then underperform the next. The solution is counterintuitive: cap your high days at 90% effort to create sustainable consistency rather than chasing peak performance followed by collapse.`});
  }

  // ——— 4. WEEKDAY PATTERNS ———
  const weekdayResult = detectWeekdayPatterns(logs);
  if (weekdayResult) {
    msgs.push({type:'warn', text:`Day-of-week analysis reveals a ${weekdayResult.spread}-point performance gap between your strongest day (${weekdayResult.bestDay}, averaging ${weekdayResult.bestAvg}%) and weakest (${weekdayResult.worstDay}, averaging ${weekdayResult.worstAvg}%). This is not random variation — it is a recurring structural pattern. Consider what differs about your ${weekdayResult.worstDay} environment, obligations, or energy level compared to ${weekdayResult.bestDay}. If ${weekdayResult.worstDay} consistently underperforms, either restructure it with lighter blocks, or address the underlying cause — typically competing obligations, poor sleep the night before, or absence of morning routine.`});
  }

  // ——— 5. TIME-OF-DAY OPTIMALITY ———
  const todResult = detectTimeOfDayOptimality(allBlocks);
  if (todResult) {
    const bestSlot = todResult.best;
    const worstSlot = todResult.worst;
    if (bestSlot.eff > worstSlot.eff * 1.5) {
      msgs.push({type:'positive', text:`Your time-of-day analysis reveals a clear cognitive performance window: ${bestSlot.slot} sessions produce ${bestSlot.eff.toFixed(1)} tests/hr across ${bestSlot.hours.toFixed(1)}h, while ${worstSlot.slot} sessions yield only ${worstSlot.eff.toFixed(1)} tests/hr. This ${((bestSlot.eff / Math.max(0.1, worstSlot.eff) - 1) * 100).toFixed(0)}% efficiency differential is significant. Schedule your highest-difficulty, highest-stakes subjects during your ${bestSlot.slot} window. Reserve ${worstSlot.slot} for review, organization, or lower-cognitive-demand tasks.`});
    }
  }

  // ——— 6. RECOVERY PATTERN ———
  const recovResult = detectRecoveryPattern(logs);
  if (recovResult) {
    if (recovResult.recoveryRate >= 70) {
      msgs.push({type:'positive', text:`Your recovery resilience is strong: after ${recovResult.badDays} below-threshold days, you bounced back ${recovResult.recoveries} times (${recovResult.recoveryRate}% recovery rate). This is a meaningful psychological indicator — it means bad days do not cascade into bad weeks for you. This resilience is a competitive advantage. Continue to treat poor sessions as isolated events rather than evidence of a larger problem.`});
    } else if (recovResult.recoveryRate < 40 && recovResult.badDays >= 3) {
      msgs.push({type:'critical', text:`Recovery analysis reveals a concerning pattern: after ${recovResult.badDays} low-execution days, you recovered only ${recovResult.recoveries} times (${recovResult.recoveryRate}% rate). ${recovResult.collapses} times, a poor day was followed by another poor day. This cascading failure pattern suggests that bad sessions are creating psychological momentum that suppresses subsequent performance. The intervention is simple but requires discipline: after any sub-60% day, reduce the next day's planned load by 30% and focus entirely on completion rate rather than volume.`});
    }
  }

  // ——— 7. SUBJECT INTELLIGENCE ———
  const recent14Blocks = allBlocks.filter(b => b.date >= dateStr(addDays(new Date(), -14)));
  if (recent14Blocks.length > 3) {
    const sa = computeSubjectAnalytics(recent14Blocks);

    if (sa.subjects.length > 0) {
      const top = sa.subjects[0];
      if (top.dominance > 55) {
        msgs.push({type:'warn', text:`Subject concentration risk: ${top.name} accounts for ${top.dominance.toFixed(0)}% of your study time over the last 14 days. While depth in a single subject has value, this level of concentration typically comes at the expense of other subjects that carry equal examination weight. The risk is invisible until it materialises as an unprepared section on test day. Deliberately allocate at least 20% of weekly hours to your two weakest subjects.`});
      }

      if (sa.neglected.length > 0) {
        msgs.push({type:'critical', text:`The following subjects have received zero logged hours in the last 14 days: ${sa.neglected.join(', ')}. This represents unmitigated examination risk. Every day without exposure to these subjects increases the retrieval difficulty when you eventually return to them. Schedule a minimum 45-minute recovery session for each neglected subject within the next 48 hours — not to master the material, but to re-establish the neural pathways before they atrophy further.`});
      }

      // Efficiency trends
      const effTrends = detectSubjectEfficiencyTrend(allBlocks);
      if (effTrends) {
        effTrends.forEach(t => {
          if (t.delta > 3) {
            msgs.push({type:'positive', text:`Efficiency in ${t.subject} has improved from ${t.early.toFixed(1)} to ${t.late.toFixed(1)} tests/hr over the last two weeks (+${t.delta.toFixed(1)}/hr). This acceleration suggests your methodology in this subject is maturing — the material is becoming more accessible to active recall. Continue the current approach; the compound effect of rising efficiency will become increasingly significant.`});
          } else if (t.delta < -3) {
            msgs.push({type:'warn', text:`Efficiency in ${t.subject} has declined from ${t.early.toFixed(1)} to ${t.late.toFixed(1)} tests/hr (−${Math.abs(t.delta).toFixed(1)}/hr). This deceleration may indicate that you are encountering more difficult material, or that your study method has shifted toward passive review. If the material has genuinely increased in difficulty, this is expected. If not, audit your session structure — are you reading without testing? Watching without practicing?`});
          }
        });
      }
    }
  }

  // ——— 8. TEST/HOUR BALANCE ———
  if (overallEff !== null && totalHrsAll > 5) {
    if (overallEff < 3) {
      msgs.push({type:'warn', text:`Across ${totalHrsAll.toFixed(1)} logged hours, your aggregate test density is ${overallEff.toFixed(1)} tests per hour. This is a passive study signature — it suggests that the majority of your time is spent on input activities (reading, watching, highlighting) rather than output activities (testing, recall, application). Research on learning science is unambiguous here: active recall at a rate of 8-12 tests per hour produces retention rates 2-3x higher than passive review at the same time investment. Every hour without testing is partially wasted time that feels productive.`});
    } else if (overallEff >= 10) {
      msgs.push({type:'positive', text:`Your aggregate test efficiency of ${overallEff.toFixed(1)} tests/hr across ${totalHrsAll.toFixed(1)}h of study represents an effective active-recall methodology. This test density is associated with strong long-term retention. The specific number matters less than the consistency — maintaining this rate across all subjects, not just the ones you find easier, is where the real advantage lies.`});
    }
  }

  // ——— 9. CONSECUTIVE LOAD ———
  const loadResult = detectConsecutiveLoad(logs);
  if (loadResult) {
    msgs.push({type:'warn', text:`You have logged ${loadResult.streak} consecutive days of heavy study volume (8+ hours planned or 7+ hours completed). While the discipline this requires is noteworthy, the cognitive science is clear: beyond three consecutive high-load days, retention efficiency degrades measurably. Performance may feel maintained, but encoding quality drops. A strategically placed lighter day — 4-5 hours focused on review and active recall — will produce better aggregate outcomes than pushing through a fourth or fifth heavy day.`});
  }

  // ——— 10. INTERRUPTION ANALYSIS ———
  if (ints.length > 0) {
    const recentInts = ints.filter(i => {
      const d = new Date(i.timestamp).toISOString().split('T')[0];
      return d >= dateStr(addDays(new Date(), -7));
    });
    if (recentInts.length >= 3) {
      const hourMap = {};
      recentInts.forEach(i => { const h = new Date(i.timestamp).getHours(); hourMap[h] = (hourMap[h]||0) + 1; });
      const sortedHours = Object.entries(hourMap).sort((a,b) => b[1] - a[1]);
      const peakHour = sortedHours[0];
      const avgPerDay = (recentInts.length / Math.min(7, week.length)).toFixed(1);
      msgs.push({type:'warn', text:`Interruption data shows ${recentInts.length} session breaks over the past week (approximately ${avgPerDay} per day). The highest concentration occurs at ${peakHour[0]}:00 (${peakHour[1]} interruptions). Each interruption carries a cognitive switching cost of 8-15 minutes of degraded focus, even after resuming. For the ${peakHour[0]}:00 hour specifically: either place your device in another room, use an app blocker, or schedule a deliberate break at that time so the interruption is controlled rather than reactive.`});
    }
  }

  // ——— 11. FATIGUE STATE ———
  if (state.fatigueIndex !== null) {
    if (state.fatigueIndex < 20) {
      msgs.push({type:'critical', text:`Your fatigue index has reached ${state.fatigueIndex}, which is in the critical depletion zone. At this level, continuing to study is not a demonstration of discipline — it is a misallocation of effort. Output quality, error rates, and encoding efficiency are all severely impaired. The highest-return action available to you right now is rest. Sleep, low-stimulation activities, and physical movement will restore more capacity than any study session you could attempt in this state. This is not a suggestion; it is a performance calculation.`});
    } else if (state.fatigueIndex < 40) {
      msgs.push({type:'warn', text:`Fatigue index at ${state.fatigueIndex} indicates elevated cognitive load. You are not yet in critical territory, but continued high-volume sessions without a recovery period will push you there within 24-48 hours. Consider tonight's sleep as the single most important variable for tomorrow's performance. Target 7.5+ hours. Avoid screens in the final hour before sleep. If tomorrow's first block is demanding, front-load an easier review session to allow cognitive warm-up.`});
    }
  }

  // ——— 12. MISSION PRESSURE ———
  if (state.mission) {
    const daysLeft = Math.max(1, Math.ceil((new Date(state.mission.targetDate) - new Date()) / 86400000));
    const compHrs = totalHrsAll;
    const remainHrs = Math.max(0, state.mission.requiredHours - compHrs);
    const needed = remainHrs / daysLeft;
    const capacity = weekHrs / Math.max(1, week.length);

    if (needed > capacity * 1.3) {
      msgs.push({type:'critical', text:`Mission trajectory analysis: you require ${needed.toFixed(1)}h per day to meet your ${state.mission.name || 'mission'} deadline in ${daysLeft} days, against a demonstrated daily capacity of ${capacity.toFixed(1)}h. The deficit is ${(needed - capacity).toFixed(1)}h per day — this is not closable through willpower alone. You have three options: extend daily hours by restructuring your schedule, extend the deadline if possible, or reduce the scope of required coverage to prioritise high-yield material. Attempting to close this gap without structural change will result in accumulated fatigue and declining quality.`});
    } else if (needed > capacity * 0.9) {
      msgs.push({type:'warn', text:`Mission pacing is tight: ${needed.toFixed(1)}h/day required against ${capacity.toFixed(1)}h demonstrated capacity. You are operating near your limit with minimal buffer for disruptions. Any unplanned day off, illness, or commitment will create a deficit that compounds. Build a 1-day buffer this week by adding 30-45 minutes to three sessions. Small margins create resilience.`});
    } else if (needed <= capacity * 0.7 && daysLeft > 7) {
      msgs.push({type:'positive', text:`Mission trajectory is favorable: daily requirement of ${needed.toFixed(1)}h sits comfortably within your ${capacity.toFixed(1)}h capacity, providing a ${(capacity - needed).toFixed(1)}h daily buffer. This buffer is valuable — use it for additional test volume or subject gap-filling rather than reducing study hours. The temptation to ease off when ahead of schedule is the most common source of missed targets in the final weeks.`});
    }
  }

  // ——— 13. FOUR-DAY DECLINE ———
  const last4 = logs.slice(-4);
  if (last4.length === 4) {
    const declining = last4.every((l, i) => i === 0 || (l.execPct||0) <= (last4[i-1].execPct||0));
    if (declining && (last4[3].execPct||0) < 70) {
      msgs.push({type:'critical', text:`Four consecutive days of declining execution: ${last4.map(l => (l.execPct||0) + '%').join(' → ')}. This is not a random fluctuation — a sustained downward trajectory indicates either accumulating fatigue, a scheduling problem that is compounding, or a motivational drift that has not been addressed. The most effective intervention at this point is not to push harder, but to pause and conduct an honest audit: are your planned hours realistic? Are block start times matching your actual wake time? Is your study environment consistently available? Fix the system, and the execution will follow.`});
    }
  }

  // ——— 14. MOMENTUM STATE ———
  const mom = state.metrics.Momentum;
  const foc = state.metrics.Focus;
  const disc = state.metrics.Discipline;
  if (mom >= 80 && foc >= 70) {
    msgs.push({type:'positive', text:`Your current metric state — Momentum ${mom}, Focus ${foc}, Discipline ${disc} — represents a high-functioning operational configuration. When these three indicators are simultaneously elevated, it typically reflects a period where your environment, schedule, and methodology are aligned. Protect this alignment. Avoid rearranging your study location, changing your wake time, or introducing new scheduling experiments during this period. The compounding effect of sustained high-metric operation is the single largest driver of long-term academic performance gains.`});
  } else if (disc < 45) {
    msgs.push({type:'warn', text:`Discipline has dropped to ${disc}, which reflects a pattern of late starts, skipped blocks, or session drift. This metric is not a judgment — it is a signal that the gap between your intentions and your actions is widening. The most common root cause is over-ambitious scheduling: when you plan sessions you cannot realistically start on time, every late start compounds the discipline penalty. Consider setting block start times 30 minutes later than your ideal — a block started on time at 09:30 is worth more than a block planned for 09:00 and started at 09:45.`});
  }

  // ——— RENDER ———
  const listEl = el('advisoryList');
  if (!msgs.length) {
    listEl.innerHTML = '<div class="no-data-inline">Continue logging sessions. The advisory engine will produce increasingly specific analysis as your data history grows.</div>';
    return;
  }
  listEl.innerHTML = msgs.map((m, i) => `<div class="advisor-msg ${m.type}" style="animation-delay:${i * 60}ms">
    <span style="font-size:8px;letter-spacing:2.5px;display:block;margin-bottom:8px;color:var(--text3);font-weight:600">${m.type === 'critical' ? 'CRITICAL' : m.type === 'warn' ? 'ATTENTION' : 'OBSERVATION'} · ASSESSMENT ${String(i+1).padStart(2,'0')}</span>
    ${m.text}
  </div>`).join('');
}

// ================================================================
// SUBJECT ANALYTICS ENGINE
// Computes per-subject stats from blocks array
// ================================================================
function computeSubjectAnalytics(blocks) {
  const cats = {};
  blocks.forEach(b => {
    const cat = b.subjectCategory || classifySubject(b.subject);
    if (!cats[cat]) cats[cat] = { name:cat, hours:0, tests:0, blocks:0, completedBlocks:0 };
    const elapsed = b.elapsed || 0;
    cats[cat].hours += elapsed / 3600;
    cats[cat].tests += b.completedTests || 0;
    cats[cat].blocks++;
    if (b.status === 'completed') cats[cat].completedBlocks++;
  });
  const totalHrs = Object.values(cats).reduce((s,c) => s + c.hours, 0);
  const subjects = Object.values(cats).map(c => ({
    ...c,
    efficiency: c.hours > 0 ? c.tests / c.hours : 0,
    dominance: totalHrs > 0 ? (c.hours / totalHrs) * 100 : 0,
  })).sort((a,b) => b.hours - a.hours);
  // Imbalance: any MATRIX_LABEL with 0h logged
  const presentCats = new Set(subjects.map(s => s.name));
  const neglected = SUBJECT_MATRIX_LABELS.filter(l => !presentCats.has(l));
  return { subjects, neglected, totalHrs };
}

// Build matrix data: { 'زیست': { 'Mon': {hours, tests} }, ... }
function buildMatrixData(weekDays, allBlocks) {
  const data = {};
  SUBJECT_MATRIX_LABELS.forEach(s => {
    data[s] = {};
    weekDays.forEach(d => { data[s][dateStr(d)] = { hours:0, tests:0 }; });
  });
  weekDays.forEach(d => {
    const ds = dateStr(d);
    const dayBlocks = allBlocks.filter(b => b.date === ds);
    dayBlocks.forEach(b => {
      const cat = b.subjectCategory || classifySubject(b.subject);
      if (data[cat]) {
        data[cat][ds].hours += (b.elapsed || 0) / 3600;
        data[cat][ds].tests += b.completedTests || 0;
      }
    });
  });
  return data;
}

// ================================================================
// REPORT ENGINE
// ================================================================
let reportState = { quick:null, start:null, end:null };

function setReportQuick(q) {
  reportState.quick=q;
  const now=new Date();
  let s,e;
  if(q==='thisweek'){const ws=new Date(now);ws.setDate(now.getDate()-now.getDay());s=dateStr(ws);e=today();}
  else if(q==='lastweek'){const we=new Date(now);we.setDate(now.getDate()-now.getDay()-1);const ws=new Date(we);ws.setDate(we.getDate()-6);s=dateStr(ws);e=dateStr(we);}
  else if(q==='thismonth'){s=`${now.getFullYear()}-${pad2(now.getMonth()+1)}-01`;e=today();}
  else if(q==='last30'){s=dateStr(addDays(now,-30));e=today();}
  else if(q==='custom'){el('reportCustomRange').style.display='flex';updateRangeLabel();return;}
  reportState.start=s; reportState.end=e;
  el('reportCustomRange').style.display='none';
  // Highlight active btn
  ['thisweek','lastweek','thismonth','last30','custom'].forEach(k=>{
    const b=el('rq-'+k);if(b) b.classList.toggle('btn-active',k===q);
  });
  updateRangeLabel();
}
function updateRangeLabel() {
  if(reportState.quick==='custom'){
    const s=el('reportStart').value,e=el('reportEnd').value;
    reportState.start=s; reportState.end=e;
    setText('reportRangeLabel',s&&e?`RANGE: ${s} → ${e}`:'Set start and end date above');
  } else if(reportState.start&&reportState.end){
    setText('reportRangeLabel',`RANGE: ${reportState.start} → ${reportState.end}`);
  }
}
el('reportStart').addEventListener('change',updateRangeLabel);
el('reportEnd').addEventListener('change',updateRangeLabel);

async function generateReport() {
  if(reportState.quick==='custom'){
    reportState.start=el('reportStart').value;
    reportState.end=el('reportEnd').value;
  }
  if(!reportState.start||!reportState.end){showToast('Select a time range first');return;}
  const allLogs=await dbGetAll('dailyLogs');
  const allInts=await dbGetAll('interruptions');
  const allFatigue=await dbGetAll('fatigueHistory');
  const allBlocks=await dbGetAll('studyBlocks');
  const s=reportState.start,e=reportState.end;

  // Filter logs in range
  const rangeLogs=allLogs.filter(l=>l.date>=s&&l.date<=e);

  // Compute previous equal-length range
  const rangeLen=Math.ceil((parseDate(e)-parseDate(s))/86400000)+1;
  const prevEnd=dateStr(addDays(parseDate(s),-1));
  const prevStart=dateStr(addDays(parseDate(s),-rangeLen));
  const prevLogs=allLogs.filter(l=>l.date>=prevStart&&l.date<=prevEnd);

  const curLogs=allLogs.slice(-7);
  const longTermLogs=allLogs;

  if(rangeLogs.length===0){
    el('reportOutput').innerHTML=`<div class="report-empty"><div class="report-empty-icon">◈</div><div class="report-empty-title">NO DATA IN SELECTED RANGE</div><div class="report-empty-desc">No study sessions were logged between ${s} and ${e}.</div></div>`;
    return;
  }

  // Subject analytics for range blocks
  const rangeBlocks = allBlocks.filter(b=>b.date>=s&&b.date<=e);
  const subjectAnalytics = computeSubjectAnalytics(rangeBlocks);

  // Week heatmap: use last 7 days of range or full range week
  const rangeEnd = parseDate(e);
  const heatmapWeekDays = Array.from({length:7},(_,i)=>addDays(rangeEnd,-6+i));
  const matrixData = buildMatrixData(heatmapWeekDays, allBlocks);

  const rm=computeRangeMetrics(rangeLogs,allBlocks,allInts,allFatigue,s,e);
  const pm=computeRangeMetrics(prevLogs,allBlocks,allInts,allFatigue,prevStart,prevEnd);
  const cm=computeRangeMetrics(curLogs,allBlocks,allInts,allFatigue,'','');
  const lm=computeRangeMetrics(longTermLogs,allBlocks,allInts,allFatigue,'','');

  const out=el('reportOutput');
  out.innerHTML=buildReportHTML(rm,pm,cm,lm,rangeLogs,s,e,rangeLen,prevStart,prevEnd,subjectAnalytics,heatmapWeekDays,matrixData);

  requestAnimationFrame(()=>{
    drawMiniCanvas('mc-exec',rangeLogs.map(l=>l.execPct||0),'var(--accent)');
    drawMiniCanvas('mc-tests',rangeLogs.map(l=>l.totalTests||0),'var(--warn)');
    drawMiniCanvas('mc-hours',rangeLogs.map(l=>(l.completedSec||0)/3600),'var(--info)');
  });
}

function computeRangeMetrics(logs,blocks,ints,fatigue,s,e) {
  if(!logs.length) return null;
  const totalHrs=logs.reduce((a,l)=>a+(l.completedSec||0),0)/3600;
  const totalTests=logs.reduce((a,l)=>a+(l.totalTests||0),0);
  const avgDailyHrs=totalHrs/logs.length;
  const avgDailyTests=totalTests/logs.length;
  const avgExec=logs.reduce((a,l)=>a+(l.execPct||0),0)/logs.length;
  const avgPlanned=logs.reduce((a,l)=>a+(l.plannedHours||0),0)/logs.length;
  const testEff=totalHrs>0?totalTests/totalHrs:0;

  // Filter blocks/ints/fatigue to date range if s/e provided
  const rb=s&&e?blocks.filter(b=>b.date>=s&&b.date<=e):blocks;
  const ri=s&&e?ints.filter(i=>new Date(i.timestamp).toISOString().split('T')[0]>=s&&new Date(i.timestamp).toISOString().split('T')[0]<=e):ints;
  const rf=s&&e?fatigue.filter(f=>f.date>=s&&f.date<=e):fatigue;

  const intCount=ri.length;
  const avgFatigue=rf.length?rf.reduce((a,f)=>a+f.fatigue,0)/rf.length:null;
  const completedBlocks=rb.filter(b=>b.status==='completed').length;
  const totalBlocks=rb.length;

  // Most productive & interrupted hours
  const hourExec={},hourInt={};
  ri.forEach(i=>{const h=new Date(i.timestamp).getHours();hourInt[h]=(hourInt[h]||0)+1;});
  rb.filter(b=>b.startTime&&b.status==='completed').forEach(b=>{const h=parseInt(b.startTime.split(':')[0]);hourExec[h]=(hourExec[h]||0)+1;});
  const bestHour=Object.keys(hourExec).sort((a,b)=>hourExec[b]-hourExec[a])[0];
  const worstHour=Object.keys(hourInt).sort((a,b)=>hourInt[b]-hourInt[a])[0];

  // Tactical rating distribution
  const ratings={overloaded:0,heavy:0,balanced:0,light:0};
  logs.forEach(l=>{
    const hrs=l.plannedHours||0;
    if(hrs>12) ratings.overloaded++;
    else if(hrs>=8) ratings.heavy++;
    else if(hrs>=4) ratings.balanced++;
    else ratings.light++;
  });

  // Focus/Discipline/Momentum trends (check first vs last log)
  const execTrend=logs.length>1?(logs[logs.length-1].execPct||0)-(logs[0].execPct||0):0;

  return {totalHrs,totalTests,avgDailyHrs,avgDailyTests,avgExec,avgPlanned,testEff,intCount,avgFatigue,completedBlocks,totalBlocks,bestHour,worstHour,ratings,execTrend,days:logs.length};
}

function cmpArrow(current,prev,higher_is_better=true) {
  if(prev===null||current===null) return {arrow:'—',cls:'arrow-neutral',delta:null};
  const d=current-prev;
  const up=higher_is_better?d>=0:d<=0;
  return {
    arrow:Math.abs(d)<0.01?'—':up?'▲':'▼',
    cls:Math.abs(d)<0.01?'arrow-neutral':up?'arrow-up':'arrow-down',
    delta:d
  };
}

function buildReportHTML(rm,pm,cm,lm,rangeLogs,s,e,rangeLen,prevStart,prevEnd,subjectAnalytics,heatmapWeekDays,matrixData) {
  const prev=pm||null;
  const a=(c,p,hib=true)=>cmpArrow(c,p,hib);

  const execA=a(rm.avgExec,prev?.avgExec);
  const hrsA=a(rm.totalHrs,prev?.totalHrs);
  const testsA=a(rm.totalTests,prev?.totalTests);
  const effA=a(rm.testEff,prev?.testEff);
  const intA=a(rm.intCount,prev?.intCount,false);
  const fatA=a(rm.avgFatigue,prev?.avgFatigue,false);

  const fmt1=(n)=>n!==null&&n!==undefined?n.toFixed(1):'—';
  const fmt0=(n)=>n!==null&&n!==undefined?Math.round(n):'—';

  const statCards=[
    {label:'AVG EXECUTION',val:fmt0(rm.avgExec)+'%',arrow:execA,cmp:prev?fmt0(prev.avgExec)+'%':null,delay:0},
    {label:'TOTAL HOURS',val:fmt1(rm.totalHrs)+'h',arrow:hrsA,cmp:prev?fmt1(prev.totalHrs)+'h':null,delay:60},
    {label:'TOTAL TESTS',val:fmt0(rm.totalTests),arrow:testsA,cmp:prev?fmt0(prev.totalTests):null,delay:120},
    {label:'TEST EFFICIENCY',val:fmt1(rm.testEff)+'/hr',arrow:effA,cmp:prev?fmt1(prev.testEff)+'/hr':null,delay:180},
    {label:'AVG DAILY HOURS',val:fmt1(rm.avgDailyHrs)+'h',arrow:a(rm.avgDailyHrs,prev?.avgDailyHrs),cmp:prev?fmt1(prev.avgDailyHrs)+'h':null,delay:200},
    {label:'AVG DAILY TESTS',val:fmt0(rm.avgDailyTests),arrow:a(rm.avgDailyTests,prev?.avgDailyTests),cmp:prev?fmt0(prev.avgDailyTests):null,delay:220},
    {label:'INTERRUPTIONS',val:fmt0(rm.intCount),arrow:intA,cmp:prev?fmt0(prev.intCount):null,delay:240},
    {label:'AVG FATIGUE',val:rm.avgFatigue!==null?fmt0(rm.avgFatigue):'—',arrow:fatA,cmp:prev&&prev.avgFatigue!==null?fmt0(prev.avgFatigue):null,delay:260},
    {label:'BLOCKS COMPLETED',val:`${rm.completedBlocks}/${rm.totalBlocks}`,arrow:{arrow:'',cls:'arrow-neutral'},cmp:null,delay:280},
    {label:'DAYS LOGGED',val:rm.days,arrow:{arrow:'',cls:'arrow-neutral'},cmp:null,delay:300},
  ].map(c=>`<div class="report-stat-card" style="animation-delay:${c.delay}ms">
    <div class="report-stat-val">${c.val}</div>
    <div class="report-stat-label">${c.label}</div>
    ${c.arrow.arrow?`<div class="report-compare-arrow ${c.arrow.cls}">${c.arrow.arrow}</div>`:''}
    ${c.cmp?`<div class="report-compare-val">prev: ${c.cmp}${c.arrow.delta!==null?' ('+(c.arrow.delta>0?'+':'')+fmt1(c.arrow.delta)+')':''}</div>`:''}
  </div>`).join('');

  const ratingDist=`<div class="rating-distribution">
    ${rm.ratings.overloaded?`<span class="rating-pill overloaded">OVERLOADED ×${rm.ratings.overloaded}</span>`:''}
    ${rm.ratings.heavy?`<span class="rating-pill heavy">HEAVY ×${rm.ratings.heavy}</span>`:''}
    ${rm.ratings.balanced?`<span class="rating-pill balanced">BALANCED ×${rm.ratings.balanced}</span>`:''}
    ${rm.ratings.light?`<span class="rating-pill light">LIGHT ×${rm.ratings.light}</span>`:''}
  </div>`;

  // Subject analytics HTML
  let subjHTML = '';
  if (subjectAnalytics && subjectAnalytics.subjects.length > 0) {
    const cards = subjectAnalytics.subjects.map(s => {
      const col = subjectCatColor(s.name);
      const rtl = isRTL(s.name);
      return `<div class="subj-card" style="border-left-color:${col}">
        <div class="subj-card-name ${rtl?'':'ltr'}">${s.name}${s.dominance>50?'<span class="highlight-badge">DOMINANT</span>':''}</div>
        <div class="subj-card-stats">
          <div class="subj-stat"><div class="subj-stat-val" style="color:${col}">${s.hours.toFixed(1)}h</div><div class="subj-stat-label">hours</div></div>
          <div class="subj-stat"><div class="subj-stat-val" style="color:${col}">${s.tests}</div><div class="subj-stat-label">tests</div></div>
          <div class="subj-stat"><div class="subj-stat-val" style="color:${col}">${s.efficiency.toFixed(1)}</div><div class="subj-stat-label">eff/hr</div></div>
          <div class="subj-stat"><div class="subj-stat-val" style="color:${col}">${s.dominance.toFixed(0)}%</div><div class="subj-stat-label">dominance</div></div>
        </div>
        <div class="subj-dominance-bar"><div class="subj-dominance-fill" style="width:${s.dominance}%;background:${col}"></div></div>
      </div>`;
    }).join('');
    const neglectedBadges = subjectAnalytics.neglected.length
      ? subjectAnalytics.neglected.map(n=>`<span class="neglected-badge">${n}</span>`).join(' ')
      : '<span style="color:var(--success);font-size:10px">All matrix subjects active</span>';
    subjHTML = `
    <div class="report-section-title">SUBJECT INTELLIGENCE — ANALYTICS</div>
    <div class="subject-analytics-grid">${cards}</div>
    <div style="margin-top:12px;display:flex;align-items:center;gap:8px;flex-wrap:wrap">
      <span style="font-size:9px;color:var(--text3);font-family:var(--font-mono);letter-spacing:1px">NEGLECTED / ABSENT:</span>
      ${neglectedBadges}
    </div>`;
  }

  // On-screen heatmap
  let heatmapHTML = '';
  if (heatmapWeekDays && matrixData) {
    // Find max cell value for scale
    let maxVal = 0;
    SUBJECT_MATRIX_LABELS.forEach(s => {
      heatmapWeekDays.forEach(d => {
        const v = matrixData[s]?.[dateStr(d)]?.hours||0;
        if (v > maxVal) maxVal = v;
      });
    });
    const heatLevel = (h) => {
      if (maxVal === 0 || h === 0) return 0;
      const r = h / maxVal;
      if (r < 0.1) return 0;
      if (r < 0.3) return 1;
      if (r < 0.55) return 2;
      if (r < 0.8) return 3;
      return 4;
    };
    const dayRow = heatmapWeekDays.map(d=>`<th>${['Sun','Mon','Tue','Wed','Thu','Fri','Sat'][d.getDay()]} ${d.getDate()}</th>`).join('');
    const rows = SUBJECT_MATRIX_LABELS.map(subj => {
      const cells = heatmapWeekDays.map(d=>{
        const ds = dateStr(d);
        const cell = matrixData[subj]?.[ds]||{hours:0,tests:0};
        const lvl = heatLevel(cell.hours);
        const disp = cell.hours>0?`${cell.hours.toFixed(1)}h / ${cell.tests}T`:'0h / 0T';
        return `<td class="heatmap-cell-${lvl}">${disp}</td>`;
      }).join('');
      return `<tr><td>${subj}</td>${cells}</tr>`;
    }).join('');
    heatmapHTML = `
    <div class="report-section-title">SUBJECT × DAY HEATMAP MATRIX (Last 7 Days of Range)</div>
    <div class="card" style="margin-bottom:16px">
      <div class="card-title"><span class="dot"></span>PERFORMANCE HEATMAP — intensity = study hours</div>
      <div class="heatmap-container">
        <table class="heatmap-table">
          <thead><tr><th>SUBJECT</th>${dayRow}</tr></thead>
          <tbody>${rows}</tbody>
        </table>
      </div>
      <div class="text-muted mt-8">Scale: darker cells = more hours. Each cell shows Xh / YT (hours / tests).</div>
    </div>`;
  }

  const humanReport=buildHumanReport(rm,pm,cm,lm,s,e,rangeLen,subjectAnalytics,heatmapWeekDays,matrixData);

  return `
    <div class="report-section-title">SUMMARY STATISTICS — ${s} to ${e}</div>
    <div class="grid-5" style="margin-bottom:16px">${statCards}</div>

    <div class="grid-3" style="margin-bottom:16px">
      <div class="card">
        <div class="card-title"><span class="dot"></span>EXECUTION TREND</div>
        <div class="mini-canvas-wrap"><canvas id="mc-exec"></canvas></div>
        <div class="mini-canvas-label">Execution % · ${rangeLogs.length} days</div>
      </div>
      <div class="card">
        <div class="card-title"><span class="dot"></span>TEST VOLUME TREND</div>
        <div class="mini-canvas-wrap"><canvas id="mc-tests"></canvas></div>
        <div class="mini-canvas-label">Tests per day</div>
      </div>
      <div class="card">
        <div class="card-title"><span class="dot"></span>STUDY HOURS TREND</div>
        <div class="mini-canvas-wrap"><canvas id="mc-hours"></canvas></div>
        <div class="mini-canvas-label">Hours per day</div>
      </div>
    </div>

    <div class="grid-2" style="margin-bottom:8px">
      <div class="card">
        <div class="card-title"><span class="dot"></span>TACTICAL RATING DISTRIBUTION</div>
        ${ratingDist}
        <div class="text-muted mt-8">Based on ${rm.days} logged days in selected range</div>
      </div>
      <div class="card">
        <div class="card-title"><span class="dot"></span>TIME PATTERNS</div>
        <div style="display:flex;flex-direction:column;gap:10px">
          <div><div style="font-size:10px;color:var(--text3);margin-bottom:3px">MOST PRODUCTIVE HOUR</div>
            <div class="font-mono" style="color:var(--accent);font-size:20px">${rm.bestHour!==undefined?rm.bestHour+':00':'—'}</div></div>
          <div><div style="font-size:10px;color:var(--text3);margin-bottom:3px">MOST INTERRUPTED HOUR</div>
            <div class="font-mono" style="color:var(--danger);font-size:20px">${rm.worstHour!==undefined?rm.worstHour+':00':'—'}</div></div>
        </div>
      </div>
    </div>

    ${subjHTML}
    ${heatmapHTML}

    ${humanReport}`;
}

function buildHumanReport(rm,pm,cm,lm,s,e,rangeLen,subjectAnalytics,heatmapWeekDays,matrixData) {
  const avgExec = Math.round(rm.avgExec);
  const prevAvgExec = pm ? Math.round(pm.avgExec) : null;
  const ltAvg = lm ? Math.round(lm.avgExec) : null;
  const testEff = rm.testEff.toFixed(1);
  const hrs = rm.totalHrs.toFixed(1);
  const tests = rm.totalTests;
  const days = rm.days;
  const rangeLabel = `${s} to ${e} (${days} days)`;

  // ——— PARAGRAPH 1: PERFORMANCE SUMMARY ———
  let p1 = '';
  const execTier = avgExec >= 90 ? 'exceptional' : avgExec >= 80 ? 'strong' : avgExec >= 65 ? 'moderate' : avgExec >= 50 ? 'below expectations' : 'critically insufficient';
  const volumeAdj = rm.avgDailyHrs >= 9 ? 'very high' : rm.avgDailyHrs >= 6 ? 'substantial' : rm.avgDailyHrs >= 4 ? 'moderate' : rm.avgDailyHrs >= 2 ? 'limited' : 'minimal';
  const effRating = parseFloat(testEff) >= 12 ? 'excellent active-recall density' : parseFloat(testEff) >= 7 ? 'solid test integration' : parseFloat(testEff) >= 3 ? 'moderate testing frequency' : 'low active-recall engagement';

  p1 = `During the period <em>${rangeLabel}</em>, your execution profile was <em>${execTier}</em>, averaging <em>${avgExec}%</em> across ${days} logged sessions. `;
  p1 += `Study volume totalled <em>${hrs} hours</em> — a ${volumeAdj} daily average of ${rm.avgDailyHrs.toFixed(1)}h — accompanied by <em>${tests} completed tests</em> at an efficiency of <em>${testEff} tests per hour</em>, which represents ${effRating}. `;

  if (rm.completedBlocks > 0 && rm.totalBlocks > 0) {
    const compRate = Math.round((rm.completedBlocks / rm.totalBlocks) * 100);
    if (compRate >= 85) p1 += `Block completion rate reached ${compRate}%, indicating strong conversion of intention into action — the most reliable predictor of sustained improvement.`;
    else if (compRate >= 60) p1 += `Block completion stood at ${compRate}%. While a majority of planned sessions were finished, the incomplete fraction represents lost compounding potential. Each unfinished block carries both a direct cost (lost study time) and an indirect cost (reduced confidence in your own planning system).`;
    else p1 += `Block completion was ${compRate}%, meaning more sessions were left incomplete than finished. This completion gap is the dominant constraint on your performance — not the quality of your study, but the reliability of your follow-through. Until this rate exceeds 75%, adding volume will not produce proportional returns.`;
  }

  // ——— PARAGRAPH 2: COMPARATIVE ANALYSIS ———
  let p2 = '';
  if (!pm || pm.days === 0) {
    p2 = `No equivalent prior period exists for direct comparison. As your log history grows beyond ${rangeLen * 2} days, this section will automatically produce trend analysis comparing current performance against your historical baseline, enabling detection of improvement trajectories, regression patterns, and seasonal performance variations.`;
  } else {
    const delta = avgExec - prevAvgExec;
    const hrsDelta = rm.totalHrs - pm.totalHrs;
    const testDelta = rm.totalTests - pm.totalTests;
    const effDelta = rm.testEff - pm.testEff;

    const execDir = delta > 2 ? `improved by ${delta} percentage points` : delta < -2 ? `declined by ${Math.abs(delta)} percentage points` : 'remained essentially stable';
    p2 = `Compared to the equivalent preceding period (${pm.days} days), execution ${execDir} — from ${prevAvgExec}% to ${avgExec}%. `;

    if (Math.abs(hrsDelta) >= 1.5) {
      p2 += `Study volume ${hrsDelta > 0 ? `increased by ${hrsDelta.toFixed(1)}h` : `decreased by ${Math.abs(hrsDelta).toFixed(1)}h`}, `;
    }
    if (Math.abs(testDelta) >= 5) {
      p2 += `test output ${testDelta > 0 ? `grew by ${testDelta}` : `contracted by ${Math.abs(testDelta)}`} tests, `;
    }
    if (Math.abs(effDelta) >= 1) {
      p2 += `and test efficiency ${effDelta > 0 ? `rose by ${effDelta.toFixed(1)}/hr` : `fell by ${Math.abs(effDelta).toFixed(1)}/hr`}. `;
    }

    if (delta >= 12) p2 += `This magnitude of improvement — exceeding 10 points — is statistically significant rather than noise. Something in your approach shifted meaningfully; identifying and reinforcing that change is the highest-leverage action available.`;
    else if (delta >= 5) p2 += `This positive movement is encouraging but not yet definitive. Sustain it for another equivalent period before treating it as a genuine trend rather than normal variance.`;
    else if (delta <= -12) p2 += `A decline of this magnitude indicates a structural shift, not a bad week. Possible contributors include fatigue accumulation, schedule disruption, environmental change, or motivational drift. Diagnosing the specific cause is essential — the corrective action for each is different.`;
    else if (delta <= -5) p2 += `This decline warrants monitoring. It may be an early indicator of a larger shift, or it may resolve naturally. If the next equivalent period shows further decline, systematic intervention is required.`;
    else p2 += `Performance stability at this level suggests a settled operating rhythm. If the current level is satisfactory relative to your mission timeline, stability is a strength. If it is insufficient, stability means the current system has reached its ceiling and structural changes (not effort changes) are required to break through.`;

    if (rm.intCount > 0 && pm.intCount > 0) {
      const intChange = rm.intCount - pm.intCount;
      if (intChange > 3) p2 += ` Notably, interruption frequency increased by ${intChange} events — this environmental deterioration may account for a portion of any performance shift.`;
    }
  }

  if (ltAvg !== null && lm.days >= 14) {
    const ltDiff = avgExec - ltAvg;
    if (Math.abs(ltDiff) >= 8) {
      const dir = ltDiff > 0 ? 'above' : 'below';
      p2 += ` Against the full historical baseline of ${ltAvg}% (${lm.days} days), this period performed <em>${Math.abs(ltDiff)} points ${dir}</em>. `;
      if (ltDiff > 0) p2 += `This divergence above baseline suggests genuine capability development rather than temporary effort.`;
      else p2 += `This divergence below baseline warrants structural attention rather than motivational intervention.`;
    } else {
      p2 += ` Long-term baseline: <em>${ltAvg}%</em> over ${lm.days} days. Current performance aligns with established operating level.`;
    }
  }

  // ——— PARAGRAPH 3: SUBJECT INTELLIGENCE & HEATMAP ———
  let p3 = '';
  if (subjectAnalytics && subjectAnalytics.subjects.length > 0) {
    const sa = subjectAnalytics;
    const top = sa.subjects[0];
    const secondTop = sa.subjects.length > 1 ? sa.subjects[1] : null;
    const dominated = top.dominance > 50;

    p3 = `Subject analysis across this period identifies <em>${sa.subjects.length} active categories</em>, with a combined volume of ${sa.totalHrs.toFixed(1)} hours. `;

    if (dominated) {
      p3 += `<em>${top.name}</em> commands ${top.dominance.toFixed(0)}% of total study time (${top.hours.toFixed(1)}h), creating a significant concentration imbalance. `;
      if (secondTop) p3 += `The next highest, ${secondTop.name}, received only ${secondTop.hours.toFixed(1)}h (${secondTop.dominance.toFixed(0)}%). `;
      p3 += `This distribution pattern, while potentially justified during intensive preparation for a specific exam, carries hidden risk: subjects receiving less than 15% of weekly hours are statistically more likely to produce examination surprises. `;
    } else {
      p3 += `<em>${top.name}</em> leads at ${top.hours.toFixed(1)}h (${top.dominance.toFixed(0)}%), with a reasonably distributed spread across active subjects. This balance reduces single-point-of-failure risk in examination scenarios. `;
    }

    if (sa.neglected.length > 0) {
      p3 += `However, <em>${sa.neglected.join(', ')}</em> received zero logged hours — these subjects represent unhedged examination exposure. Memory research indicates that even 30 minutes of spaced retrieval practice prevents the exponential decay that occurs after 14+ days of zero contact with material. `;
    }

    // Efficiency commentary
    const highEff = sa.subjects.find(s => s.efficiency > 10 && s.hours > 1);
    const lowEff = sa.subjects.find(s => s.efficiency < 3 && s.hours > 2);
    if (highEff) p3 += `Active recall performance is particularly strong in ${highEff.name} (${highEff.efficiency.toFixed(1)} tests/hr) — this methodology should be replicated across all subjects. `;
    if (lowEff) p3 += `Conversely, ${lowEff.name} shows only ${lowEff.efficiency.toFixed(1)} tests/hr despite ${lowEff.hours.toFixed(1)}h invested — this passive study signature suggests time is being consumed without proportional learning output. `;

    // Heatmap pattern
    if (matrixData && heatmapWeekDays) {
      let emptyDays = 0, spikeDays = [], maxDayTotal = 0;
      heatmapWeekDays.forEach(d => {
        const ds = dateStr(d);
        const dayTotal = SUBJECT_MATRIX_LABELS.reduce((sum, sub) => sum + (matrixData[sub]?.[ds]?.hours || 0), 0);
        if (dayTotal === 0) emptyDays++;
        if (dayTotal > 9) spikeDays.push({ day: fmtDateShort(d), hours: dayTotal });
        maxDayTotal = Math.max(maxDayTotal, dayTotal);
      });
      if (emptyDays >= 2) p3 += `The weekly heatmap reveals <em>${emptyDays} days with zero logged activity</em>. Each gap day produces disproportionate retention loss — distributed daily practice, even in 30-minute blocks, dramatically outperforms irregular intensive sessions. `;
      if (spikeDays.length > 0) p3 += `Volume spikes occurred on ${spikeDays.map(s => s.day + ' (' + s.hours.toFixed(1) + 'h)').join(', ')} — research consistently shows that single-day intensive sessions produce lower retention per hour than the same volume distributed across multiple days. `;
    }
  } else {
    p3 = `No subject classification data is available for this period. To enable subject-intelligence analysis, ensure study blocks are logged with subject names that match the classification system (e.g., ریاضی, Physics, شیمی). The system automatically categorises blocks into the 8-subject matrix for heatmap and efficiency tracking.`;
  }

  // ——— PARAGRAPH 4: CURRENT STATE ASSESSMENT ———
  let p4 = '';
  const mom = state.metrics.Momentum;
  const foc = state.metrics.Focus;
  const disc = state.metrics.Discipline;
  const fatLabel = rm.avgFatigue !== null ? (rm.avgFatigue >= 60 ? 'stable' : rm.avgFatigue >= 40 ? 'elevated' : rm.avgFatigue >= 25 ? 'concerning' : 'critical') : 'unmeasured';

  p4 = `Your current operational state registers Momentum at <em>${mom}</em>, Focus at <em>${foc}</em>, and Discipline at <em>${disc}</em>. `;

  if (mom >= 75 && foc >= 65 && disc >= 65) {
    p4 += `This tri-metric alignment in the upper ranges represents your highest-performing configuration. All three systems are functioning in mutual reinforcement. `;
  } else if (mom < 40 || foc < 40 || disc < 40) {
    const weak = mom < 40 ? 'Momentum' : foc < 40 ? 'Focus' : 'Discipline';
    p4 += `<em>${weak}</em> at its current level is the primary constraint. `;
    if (weak === 'Focus') p4 += `This typically reflects environmental factors — interruptions, multi-tasking, or insufficient sleep quality. `;
    else if (weak === 'Discipline') p4 += `This typically reflects scheduling misalignment — blocks planned at times you cannot consistently honour. `;
    else p4 += `This typically reflects inconsistency — alternating between high and low effort days, which prevents the accumulation of forward energy. `;
  }

  p4 += `Fatigue across this period averaged <em>${rm.avgFatigue !== null ? Math.round(rm.avgFatigue) : 'N/A'}</em>, assessed as <em>${fatLabel}</em>. `;
  if (rm.avgFatigue !== null && rm.avgFatigue < 35) p4 += `At this fatigue level, cognitive resources are measurably depleted. Output may feel normal subjectively, but encoding efficiency, error rates, and creative problem-solving are all degraded. `;

  if (rm.intCount > rm.days * 2) {
    p4 += `Interruption density averaged ${(rm.intCount / rm.days).toFixed(1)} per day — substantially above the 1.0 per day threshold associated with deep work. Each interruption carries an estimated 10-15 minute focus recovery cost, creating cumulative losses of ${Math.round(rm.intCount * 12)} minutes of effective study time across this period. `;
  }

  if (rm.execTrend > 12) p4 += `Execution trended upward across the period, indicating improving systems and growing capability.`;
  else if (rm.execTrend < -12) p4 += `Execution trended downward across the period — this trajectory, if sustained, will compound into significant mission-level consequences within 1-2 weeks.`;
  else p4 += `Execution was directionally stable with no significant trend, suggesting a settled operating rhythm.`;

  // ——— PARAGRAPH 5: STRATEGIC DIRECTION ———
  let p5 = '';

  // Primary strategic recommendation based on data
  if (avgExec < 60) {
    p5 += `The primary strategic imperative is not to study more — it is to study more reliably. Your current execution level indicates that planned sessions are not converting into completed work. Before increasing volume, reduce your daily planned blocks by 25-30% and focus exclusively on completion rate. A day with 4 completed blocks outperforms a day with 7 planned and 3 finished, both in learning outcomes and in the psychological reinforcement that builds long-term discipline. `;
  } else if (rm.totalHrs > 10 && rm.testEff < 4) {
    p5 += `The primary strategic opportunity lies in <em>test density</em>, not study volume. With ${hrs}h logged and only ${testEff} tests per hour, a substantial portion of your time is allocated to passive input activities. Implement a mandatory testing protocol: no study block should conclude without at least 5 minutes of active recall. Even converting 20% of passive time to active testing would meaningfully accelerate retention. `;
  } else if (avgExec >= 80 && rm.avgDailyHrs < 5.5) {
    p5 += `Your execution quality is high, which means the primary growth lever available is <em>volume</em>. A disciplined increase of 1-1.5 hours per day, distributed across 2-3 additional blocks rather than extending existing ones, would produce compounding returns without jeopardising your completion rate. The key constraint is ensuring the additional blocks are scheduled at realistic times — front-load them in your highest-performance window rather than appending them to the end of the day. `;
  } else if (avgExec >= 85 && rm.testEff >= 8) {
    p5 += `Your current configuration — high execution (${avgExec}%), strong test density (${testEff}/hr), and consistent volume (${rm.avgDailyHrs.toFixed(1)}h/day) — represents an optimised study system. The strategic priority now is <em>maintenance and consistency</em>. The single greatest risk to high performers is self-disruption: changing what works because it has become routine. Resist the urge to redesign your schedule. The compound effect of maintaining this level for another 14-21 days will produce disproportionate results. `;
  } else {
    p5 += `Your performance profile suggests a balanced but improvable system. The highest-return intervention is identifying and addressing your single largest friction source. Review the past week: which block was most frequently incomplete? Which subject felt most resistant? Which time slot produced the worst output? Address that one constraint and overall execution will shift by 5-10 points. `;
  }

  // Mission-aware strategic guidance
  if (state.mission) {
    const dL = Math.max(1, Math.ceil((new Date(state.mission.targetDate) - new Date()) / 86400000));
    const allLogHrs = lm ? lm.totalHrs : rm.totalHrs;
    const remH = Math.max(0, state.mission.requiredHours - allLogHrs);
    const nH = remH / dL;
    if (nH > rm.avgDailyHrs * 1.3) {
      p5 += `Mission deadline analysis projects a daily requirement of <em>${nH.toFixed(1)}h</em> against a demonstrated average of <em>${rm.avgDailyHrs.toFixed(1)}h</em>. This gap requires structural intervention: either extend daily hours through schedule optimisation, prioritise high-yield material to reduce total hours needed, or — if possible — negotiate the timeline. Willpower alone will not close a systematic capacity deficit. `;
    } else if (nH <= rm.avgDailyHrs * 0.8 && dL > 14) {
      p5 += `Mission pacing is comfortable. Use the buffer to invest in neglected subjects and additional test volume rather than reducing study hours. Students who ease off when ahead of schedule frequently lose their advantage in the final phase. `;
    }
  }

  // Closing with subject-specific actionable
  if (subjectAnalytics && subjectAnalytics.neglected.length > 0) {
    p5 += `Immediate action item: schedule at least one 45-minute session for each of the following neglected subjects within the next 72 hours: <em>${subjectAnalytics.neglected.join(', ')}</em>. The goal is not mastery but contact — re-establishing retrieval pathways before they decay further.`;
  } else if (subjectAnalytics && subjectAnalytics.subjects.length > 0) {
    const lowest = subjectAnalytics.subjects[subjectAnalytics.subjects.length - 1];
    if (lowest.hours < 2) {
      p5 += `Immediate action item: increase allocation to <em>${lowest.name}</em>, which received only ${lowest.hours.toFixed(1)}h in this period. Even a single additional session per week would meaningfully reduce examination risk in this subject.`;
    }
  }

  return `<div class="human-report">
    <div class="human-report-header">
      <div class="human-report-icon">◈</div>
      <div>
        <div class="human-report-title">ADVISOR ASSESSMENT</div>
        <div class="human-report-subtitle">Generated from ${rm.days}-day analysis · ${new Date().toLocaleString()}</div>
      </div>
    </div>
    <div class="report-paragraph p-summary">
      <span class="report-paragraph-tag">01 · PERFORMANCE SUMMARY</span>
      ${p1}
    </div>
    <div class="report-paragraph p-comparison">
      <span class="report-paragraph-tag">02 · COMPARATIVE ANALYSIS</span>
      ${p2}
    </div>
    <div class="report-paragraph p-assessment">
      <span class="report-paragraph-tag">03 · SUBJECT INTELLIGENCE & DISTRIBUTION</span>
      ${p3}
    </div>
    <div class="report-paragraph p-assessment" style="border-left-color:var(--warn)">
      <span class="report-paragraph-tag">04 · OPERATIONAL STATE ASSESSMENT</span>
      ${p4}
    </div>
    <div class="report-paragraph p-strategy">
      <span class="report-paragraph-tag">05 · STRATEGIC DIRECTION</span>
      ${p5}
    </div>
  </div>`;
}

// mini canvas spark line
function drawMiniCanvas(id,data,color) {
  const canvas=el(id);
  if(!canvas||!data.length) return;
  const dpr=window.devicePixelRatio||1;
  const W=canvas.offsetWidth||200,H=60;
  canvas.width=W*dpr; canvas.height=H*dpr;
  canvas.style.width=W+'px'; canvas.style.height=H+'px';
  const ctx=canvas.getContext('2d');
  ctx.scale(dpr,dpr);
  const max=Math.max(...data,0.01),min=0;
  const pad=4;
  const step=data.length>1?(W-pad*2)/(data.length-1):0;
  ctx.clearRect(0,0,W,H);
  // Fill
  ctx.beginPath();
  ctx.moveTo(pad,(H-pad)-(((data[0]-min)/(max-min))*(H-pad*2)));
  data.forEach((v,i)=>{const x=pad+i*step;const y=(H-pad)-(((v-min)/(max-min))*(H-pad*2));ctx.lineTo(x,y);});
  ctx.lineTo(pad+step*(data.length-1),H-pad);ctx.lineTo(pad,H-pad);ctx.closePath();
  const grad=ctx.createLinearGradient(0,0,0,H);
  grad.addColorStop(0,color.replace('var(','')+')');
  ctx.fillStyle=grad;
  // Solid area fill with transparency approach
  ctx.globalAlpha=0.15; ctx.fill(); ctx.globalAlpha=1;
  // Line
  ctx.beginPath();
  data.forEach((v,i)=>{const x=pad+i*step;const y=(H-pad)-(((v-min)/(max-min))*(H-pad*2));i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);});
  ctx.strokeStyle=color.includes('var')? getCSSVar(color):color;
  ctx.lineWidth=1.5; ctx.stroke();
  // Dots
  data.forEach((v,i)=>{
    const x=pad+i*step;const y=(H-pad)-(((v-min)/(max-min))*(H-pad*2));
    ctx.beginPath();ctx.arc(x,y,2,0,Math.PI*2);
    ctx.fillStyle=ctx.strokeStyle; ctx.fill();
  });
}
function getCSSVar(v) {
  const name=v.replace('var(','').replace(')','').trim();
  return getComputedStyle(document.documentElement).getPropertyValue(name).trim()||'#00ff88';
}

// ================================================================
// PLANNED HOURS / TARGETS
// ================================================================
async function loadTodayLog() {
  const log=await dbGet('dailyLogs',today());
  // CLEAN START: no default hours
  state.todayLog=log||{date:today(),plannedHours:0,dailyTestTarget:0,weeklyTestTarget:0};
  const ph=el('plannedHoursInput');
  const dt=el('dailyTestTarget');
  const wt=el('weeklyTestTarget');
  if(ph) ph.value=state.todayLog.plannedHours||'';
  if(dt) dt.value=state.todayLog.dailyTestTarget||'';
  if(wt) wt.value=state.todayLog.weeklyTestTarget||'';
}
async function savePlannedHours() {
  const ph=parseFloat(el('plannedHoursInput').value)||0;
  const dt=parseInt(el('dailyTestTarget').value)||0;
  const wt=parseInt(el('weeklyTestTarget').value)||0;
  state.todayLog=state.todayLog||{date:today()};
  state.todayLog.plannedHours=ph;
  state.todayLog.dailyTestTarget=dt;
  state.todayLog.weeklyTestTarget=wt;
  await dbPut('dailyLogs',state.todayLog);
  await calculateTodayExecution();
  showToast(`Targets set: ${ph}h planned, ${dt} tests/day`);
}

// ================================================================
// THEME ENGINE
// ================================================================
async function loadTheme() { const t=await dbGet('themes','active'); if(t) setTheme(t.name,false); }
async function setTheme(name,save=true) {
  document.body.className=document.body.className.replace(/theme-\w+/g,'').trim();
  if(name==='midnight') document.body.classList.add('theme-midnight');
  else if(name==='graphite') document.body.classList.add('theme-graphite');
  state.theme=name;
  document.querySelectorAll('.theme-btn').forEach(b=>b.classList.remove('active'));
  const btn=el('theme-'+name); if(btn) btn.classList.add('active');
  if(save) await dbPut('themes',{id:'active',name});
}

// ================================================================
// BACKUP
// ================================================================
async function exportBackup() {
  const stores=['dailyLogs','studyBlocks','metrics','habits','streaks','performanceHistory','mission','themes','interruptions','fatigueHistory'];
  const data={};
  for(const s of stores) data[s]=await dbGetAll(s);
  data.exportDate=today(); data.version=DB_VERSION;
  const blob=new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
  const url=URL.createObjectURL(blob);
  const a=document.createElement('a');
  a.href=url;a.download=`execution-backup-${today()}.json`;a.click();
  URL.revokeObjectURL(url);
  await dbPut('themes',{id:'lastBackup',name:today()});
  setText('lastBackupInfo','Last backup: '+today());
  el('backupBanner').classList.remove('active');
  showToast('Backup exported.');
}
async function importBackup(event) {
  const file=event.target.files[0];if(!file) return;
  const reader=new FileReader();
  reader.onload=async e=>{
    try{
      const data=JSON.parse(e.target.result);
      if(!data.dailyLogs||!data.studyBlocks) throw new Error('Invalid structure');
      showConfirm('RESTORE BACKUP',`Overwrite all data with backup from ${data.exportDate||'unknown date'}?`,async()=>{
        const stores=['dailyLogs','studyBlocks','metrics','habits','streaks','performanceHistory','mission','themes','interruptions','fatigueHistory'];
        for(const s of stores){await dbClear(s);if(data[s]) for(const item of data[s]) await dbPut(s,item);}
        showToast('Backup restored. Reloading...');
        setTimeout(()=>location.reload(),1500);
      });
    }catch(err){alert('Invalid backup: '+err.message);}
  };
  reader.readAsText(file);
  event.target.value='';
}
async function checkBackupReminder() {
  const last=await dbGet('themes','lastBackup');
  if(!last){el('backupBanner').classList.add('active');return;}
  const days=(new Date()-new Date(last.name))/86400000;
  if(days>=3) el('backupBanner').classList.add('active');
  setText('lastBackupInfo','Last backup: '+last.name);
}

// ================================================================
// DASHBOARD RENDER
// ================================================================
async function renderDashboard() {
  renderAllMetrics();
  await updateStreaks();
  await updateRank();
  await renderPerfBars();
  await calculateFatigue();
  await calculateTodayExecution();
  await updateMissionPressure();
  await checkCommandMode();
}

// ================================================================
// UI HELPERS
// ================================================================
function switchView(name,btn) {
  document.querySelectorAll('.view').forEach(v=>v.classList.remove('active'));
  document.querySelectorAll('.nav-btn').forEach(b=>b.classList.remove('active'));
  el('view-'+name).classList.add('active');
  if(btn) btn.classList.add('active');
  state.currentView=name;
  if(name==='blocks') renderBlocks();
  if(name==='calendar') renderCalendar();
  if(name==='advisor') generateAdvisory();
  if(name==='habits') renderHabits();
  if(name==='mission') updateMissionPressure();
  if(name==='dashboard') renderDashboard();
  if(name==='journal') initJournalView();
}
function openModal(id){el(id).classList.add('active');}
function closeModal(id){el(id).classList.remove('active');}
let confirmCallback=null;
function showConfirm(title,text,cb) {
  setText('confirmTitle',title);setText('confirmText',text);
  confirmCallback=cb;
  el('confirmOkBtn').onclick=()=>{closeModal('confirmModal');if(confirmCallback) confirmCallback();};
  openModal('confirmModal');
}
function confirmReset() {
  showConfirm('RESET ALL DATA','This permanently erases all stored data. Cannot be undone.',async()=>{
    const stores=['dailyLogs','studyBlocks','metrics','habits','streaks','performanceHistory','mission','themes','interruptions','fatigueHistory'];
    for(const s of stores) await dbClear(s);
    showToast('All data erased. Reloading...');
    setTimeout(()=>location.reload(),1500);
  });
}
function showToast(msg) {
  const t=document.createElement('div');
  t.style.cssText='position:fixed;bottom:20px;right:20px;background:var(--bg3);border:1px solid var(--border2);color:var(--text);padding:10px 16px;border-radius:var(--radius);font-size:11px;font-family:var(--font-mono);z-index:999;animation:msgFade 0.2s ease;max-width:340px;box-shadow:0 4px 20px rgba(0,0,0,0.5)';
  t.textContent=msg; document.body.appendChild(t);
  setTimeout(()=>t.remove(),3000);
}
document.querySelectorAll('.modal-overlay').forEach(o=>{ o.addEventListener('click',e=>{if(e.target===o) o.classList.remove('active');}); });

// ================================================================
// BREAK TIMER CHECK
// ================================================================
let lastActivity=Date.now();
setInterval(async()=>{
  const paused=state.blocks.filter(b=>b.status==='paused'&&b.date===today());
  if(paused.length>0){
    const idle=(Date.now()-lastActivity)/60000;
    if(idle>15){await adjustMetric('Focus',-3);showToast('Extended break detected — Focus -3');lastActivity=Date.now();}
  }
},60000);
document.addEventListener('click',()=>{lastActivity=Date.now();});
document.addEventListener('keydown',()=>{lastActivity=Date.now();});

// ================================================================
// JOURNAL PDF EXPORT ENGINE — v3
// Operational Daily PDF, Operational Weekly Single-Page PDF (8×9 heatmap),
// Full Analytical PDF. Pure offline Canvas→JPEG→PDF. No external libs.
// ================================================================

const journalState = {
  mode: 'day',
  pdfTheme: 'light',
  dayDate: today(),
  weekRefDate: today(),
  weekStartDay: 1,
};

function initJournalView() {
  if (!el('jrnlDayDate').value) el('jrnlDayDate').value = today();
  if (!el('jrnlWeekRefDate').value) el('jrnlWeekRefDate').value = today();
  updateJournalPreview();
}
function setJournalMode(m) {
  journalState.mode = m;
  ['day','week'].forEach(k => el('jm-'+k).classList.toggle('active', k === m));
  el('jrnlDayOpts').style.display  = m === 'day'  ? '' : 'none';
  el('jrnlWeekOpts').style.display = m === 'week' ? '' : 'none';
  updateJournalPreview();
}
function setJournalPdfTheme(t) {
  journalState.pdfTheme = t;
  ['dark','light'].forEach(k => el('jpt-'+k).classList.toggle('active', k === t));
}
function updateJournalPreview() {
  journalState.dayDate     = el('jrnlDayDate').value || today();
  journalState.weekRefDate = el('jrnlWeekRefDate').value || today();
  journalState.weekStartDay = parseInt(el('jrnlWeekStartDay').value);

  if (journalState.mode === 'day') {
    const blocks = state.blocks.filter(b => b.date === journalState.dayDate);
    el('jrnlPageCount').textContent = '1 PAGE';
    el('jrnlPageList').innerHTML = `
      <div class="jrnl-page-item">
        <span class="jrnl-page-num">P.01</span>
        <span class="jrnl-page-desc">${fmtDateFull(parseDate(journalState.dayDate))} — Operational Daily Journal</span>
        <span class="jrnl-page-blocks">${blocks.length} block${blocks.length!==1?'s':''}</span>
      </div>`;
  } else {
    const days = getWeekDays(journalState.weekRefDate, journalState.weekStartDay);
    el('jrnlWeekRangeLabel').textContent = `Week: ${fmtDateShort(days[0])} → ${fmtDateShort(days[6])}`;
    el('jrnlPageCount').textContent = '1 PAGE';
    el('jrnlPageList').innerHTML = `
      <div class="jrnl-page-item">
        <span class="jrnl-page-num">P.01</span>
        <span class="jrnl-page-desc">Weekly Operational Summary + 8×9 Heatmap Matrix (${fmtDateShort(days[0])} – ${fmtDateShort(days[6])})</span>
        <span class="jrnl-page-blocks" style="color:var(--warn)">MATRIX</span>
      </div>`;
  }
}

// --- Date helpers ---
function fmtDateFull(d) {
  if (!(d instanceof Date)) d = parseDate(d);
  return ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'][d.getDay()]
    + ', ' + monthNames[d.getMonth()] + ' ' + d.getDate() + ', ' + d.getFullYear();
}
function fmtDateShort(d) {
  if (!(d instanceof Date)) d = parseDate(d);
  return monthNames[d.getMonth()].slice(0,3) + ' ' + d.getDate();
}
function getWeekDays(refDateStr, startDay) {
  const ref = parseDate(refDateStr);
  const dow = ref.getDay();
  let delta = (dow - startDay + 7) % 7;
  const start = addDays(ref, -delta);
  return Array.from({length:7}, (_,i) => addDays(start, i));
}

// --- PDF Theme palettes ---
function getJournalPalette(pdfTheme) {
  const appAccent = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || '#00ff88';
  if (pdfTheme === 'dark') {
    return { bg:'#0f0f0f',surface:'#1a1a1a',border:'#2c2c2c',border2:'#3a3a3a',text:'#e8e8e8',textDim:'#777',textLight:'#444',accent:appAccent,headerBg:'#000',headerText:appAccent,tableBg:'#0f0f0f',tableAlt:'#141414',tableHead:'#1a1a1a',heatLow:'rgba(0,221,204,',heatHigh:appAccent };
  }
  return { bg:'#ffffff',surface:'#f4f4f4',border:'#d8d8d8',border2:'#c0c0c0',text:'#1a1a1a',textDim:'#666',textLight:'#999',accent:'#1a5e38',headerBg:'#1a1a1a',headerText:'#ffffff',tableBg:'#ffffff',tableAlt:'#f7f7f7',tableHead:'#1a1a1a',heatLow:'rgba(37,99,235,',heatHigh:'#1d4ed8' };
}

// --- Canvas page dimensions (A4 @ ~118dpi) ---
const PDF_W = 992, PDF_H = 1403, M = 52, CW = 992 - 104;

function makeCanvas(W,H) { const c=document.createElement('canvas');c.width=W;c.height=H;return c; }
function canvasToJpeg(canvas,q) {
  return new Promise(r=>{canvas.toBlob(b=>{const rd=new FileReader();rd.onload=()=>r(rd.result);rd.readAsDataURL(b);},'image/jpeg',q||0.93);});
}
function roundRect(ctx,x,y,w,h,r){ctx.beginPath();ctx.moveTo(x+r,y);ctx.lineTo(x+w-r,y);ctx.quadraticCurveTo(x+w,y,x+w,y+r);ctx.lineTo(x+w,y+h-r);ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);ctx.lineTo(x+r,y+h);ctx.quadraticCurveTo(x,y+h,x,y+h-r);ctx.lineTo(x,y+r);ctx.quadraticCurveTo(x,y,x+r,y);ctx.closePath();}
function truncStr(s,maxPx,ctx){if(!s)return'';let t=s;while(t.length>0&&ctx.measureText(t).width>maxPx)t=t.slice(0,-1);if(t.length<s.length)t=t.slice(0,-1)+'…';return t;}

function drawPageHeader(ctx,P,pageLabel,dateLabel,pageNum,totalPages){
  ctx.fillStyle=P.headerBg;ctx.fillRect(0,0,PDF_W,88);
  ctx.fillStyle=P.accent;ctx.fillRect(0,0,5,88);
  ctx.fillStyle=P.headerText;ctx.font='bold 13px monospace';ctx.textAlign='left';ctx.fillText('EXECUTION ENGINE',M,32);
  ctx.fillStyle=P.textLight;ctx.font='9px monospace';ctx.fillText('TACTICAL ADVISOR EDITION · PLANNING JOURNAL',M,50);ctx.fillText('GENERATED: '+new Date().toLocaleDateString('en-GB'),M,66);
  ctx.textAlign='right';ctx.fillStyle=P.headerText;ctx.font='bold 15px monospace';ctx.fillText(dateLabel,PDF_W-M,35);
  ctx.fillStyle=P.textDim;ctx.font='9px monospace';ctx.fillText(pageLabel.toUpperCase(),PDF_W-M,52);ctx.fillText('PAGE '+pageNum+' / '+totalPages,PDF_W-M,68);ctx.textAlign='left';
}
function drawPageFooter(ctx,P,label){
  const y=PDF_H-36;ctx.fillStyle=P.border;ctx.fillRect(M,y,CW,1);
  ctx.fillStyle=P.textLight;ctx.font='8px monospace';ctx.fillText('EXECUTION ENGINE · TACTICAL ADVISOR EDITION',M,y+16);
  ctx.textAlign='right';ctx.fillStyle=P.accent;ctx.fillText(label||'',PDF_W-M,y+16);ctx.textAlign='left';
}
function drawStatBox(ctx,P,x,y,w,h,label,value,r){
  ctx.fillStyle=P.surface;roundRect(ctx,x,y,w,h,r||3);ctx.fill();
  ctx.strokeStyle=P.border;ctx.lineWidth=1;roundRect(ctx,x,y,w,h,r||3);ctx.stroke();
  ctx.fillStyle=P.accent;ctx.fillRect(x,y,w,3);
  ctx.fillStyle=P.text;ctx.font='bold 18px monospace';ctx.fillText(String(value),x+12,y+38);
  ctx.fillStyle=P.textDim;ctx.font='7.5px monospace';ctx.fillText(label,x+12,y+56);
}

// --- Operational DAILY PDF ---
// ================================================================
// PAGE RENDERERS — Using VectorPDF
// ================================================================

async function renderDailyOpsPDF(dateObj, blocks, log, mission, fatigueIdx, pdfTheme) {
  const dark = pdfTheme === 'dark';
  const pdf = new VectorPDF();
  pdf.addPage();

  const ac = dark ? [0, 1, 0.53] : [0.1, 0.37, 0.22];
  const tx = dark ? [0.9, 0.9, 0.93] : [0.12, 0.12, 0.12];
  const dim = dark ? [0.45, 0.45, 0.55] : [0.5, 0.5, 0.5];
  const statFn = dark ? 'statBoxDark' : 'statBox';

  pdf.pageHeader('Operational Daily Journal', 'Tactical Advisor Edition', fmtDateFull(dateObj), 1, 1, dark);

  // Stats row
  const planH = log?.plannedHours || 0;
  const compTests = blocks.reduce((s,b) => s + (b.completedTests||0), 0);
  const totTests = blocks.reduce((s,b) => s + (b.tests||0), 0);
  const execPct = log?.execPct || 0;
  const fatLabel = fatigueIdx === null ? '--' : fatigueIdx >= 60 ? 'STABLE' : fatigueIdx >= 40 ? 'ELEVATED' : fatigueIdx >= 25 ? 'WARNING' : 'CRITICAL';
  const tactLoad = planH > 10 ? 'OVERLOAD' : planH >= 7 ? 'HEAVY' : planH >= 4 ? 'BALANCED' : 'LIGHT';

  const sw = Math.floor((pdf.CW - 36) / 4);
  let sy = pdf.y;
  [{l:'PLANNED HOURS',v:planH>0?planH+'h':'--'},{l:'TESTS TARGET',v:totTests>0?String(totTests):'--'},{l:'EXECUTION %',v:execPct>0?execPct+'%':'--'},{l:'FATIGUE / LOAD',v:fatLabel+' / '+tactLoad}]
    .forEach((s,i) => pdf[statFn](pdf.M + i*(sw+12), sy - 48, sw, 48, s.l, s.v, ac));
  sy -= 60;

  // Subject breakdown
  const sa = computeSubjectAnalytics(blocks);
  if (sa.subjects.length > 0) {
    pdf.text('SUBJECT BREAKDOWN', pdf.M, sy, { size: 7, mono: true, bold: true, color: dim });
    pdf.line(pdf.M, sy - 2, pdf.M + pdf.CW, sy - 2, dark ? [0.18,0.18,0.24] : [0.85,0.85,0.85], 0.5);
    sy -= 14;
    const sbw = Math.floor((pdf.CW - 8 * Math.min(sa.subjects.length, 6)) / Math.min(sa.subjects.length, 6));
    sa.subjects.slice(0, 6).forEach((s, i) => {
      const sx = pdf.M + i * (sbw + 8);
      const bg = dark ? [0.08, 0.08, 0.10] : [0.95, 0.95, 0.95];
      pdf.rect(sx, sy - 30, sbw, 30, bg, dark ? [0.18,0.18,0.24] : [0.85,0.85,0.85], 0.5);
      pdf.smartText(s.name, sx + 4, sy - 8, { size: 7, bold: true, mono: true, color: tx, maxWidth: sbw - 8 });
      pdf.text(`${s.hours.toFixed(1)}h / ${s.tests}T`, sx + 4, sy - 22, { size: 6, mono: true, color: dim });
    });
    sy -= 42;
  }

  // Advisory
  let advLines = [];
  if (execPct >= 85) advLines.push('Strong execution. Maintain current session structure into tomorrow.');
  else if (execPct >= 60) advLines.push('Moderate execution. Review incomplete blocks for rescheduling.');
  else if (execPct > 0) advLines.push('Below threshold. Identify the primary friction source before planning tomorrow.');
  else advLines.push('No execution logged. Begin with highest-priority block.');
  if (fatigueIdx !== null && fatigueIdx < 40) advLines.push('Fatigue alert: prioritise sleep and reduce late sessions tonight.');
  if (mission) {
    const dL = Math.max(1, Math.ceil((new Date(mission.targetDate) - new Date()) / 86400000));
    advLines.push(`Mission: ${dL}d remaining.`);
  }
  if (sa.neglected.length > 0) advLines.push('Neglected: ' + sa.neglected.slice(0, 3).join(', '));

  const advBg = dark ? [0.08, 0.08, 0.10] : [0.96, 0.96, 0.96];
  const advH = advLines.length * 11 + 14;
  pdf.rect(pdf.M, sy - advH, pdf.CW, advH, advBg, dark ? [0.18,0.18,0.24] : [0.85,0.85,0.85], 0.5);
  pdf.rect(pdf.M, sy - advH, 2, advH, ac);
  pdf.text('ADVISORY SUMMARY', pdf.M + 6, sy - 8, { size: 6, mono: true, bold: true, color: dim });
  advLines.forEach((line, i) => {
    pdf.text(line, pdf.M + 6, sy - 18 - i * 11, { size: 7, mono: true, color: tx });
  });
  sy -= advH + 12;

  // Session planning table
  pdf.text('SESSION PLANNING TABLE', pdf.M, sy, { size: 7, mono: true, bold: true, color: dim });
  sy -= 6;

  const cols = [
    { label: 'SUBJECT', w: Math.round(pdf.CW * 0.18), bold: true, mono: true },
    { label: 'OBJECT / TOPIC', w: Math.round(pdf.CW * 0.22), dim: true },
    { label: 'DUR.', w: Math.round(pdf.CW * 0.08), mono: true },
    { label: 'TESTS', w: Math.round(pdf.CW * 0.08), mono: true },
    { label: 'PRI', w: Math.round(pdf.CW * 0.08), mono: true, bold: true, colorFn: (v) => v === 'HIGH' ? [0.85,0.2,0.15] : v === 'MED' ? [0.85,0.55,0] : dim },
    { label: 'DONE', w: Math.round(pdf.CW * 0.07), type: 'checkbox' },
    { label: 'NOTES', w: pdf.CW - Math.round(pdf.CW * 0.18) - Math.round(pdf.CW * 0.22) - Math.round(pdf.CW * 0.08) * 3 - Math.round(pdf.CW * 0.07), dim: true },
  ];

  const maxTableRows = Math.max(blocks.length, Math.floor((sy - pdf.M - 40) / 18));
  const emptyRows = Math.max(0, maxTableRows - blocks.length);
  const rows = [
    ...blocks.map(b => {
      const score = (b.tests||0) * 2 + (b.duration||0) / 30;
      const pri = score >= 8 ? 'HIGH' : score >= 4 ? 'MED' : 'LOW';
      return [b.subject, b.blockObject || '', (b.duration||0) + 'm', String(b.tests||0), pri, b.status === 'completed', ''];
    }),
    ...Array(emptyRows).fill(['', '', '', '', '', false, ''])
  ];

  pdf.table(pdf.M, sy, cols, rows.slice(0, maxTableRows), { dark, rowH: 17, headH: 18 });

  pdf.pageFooter(fmtDateFull(dateObj).toUpperCase(), dark);
  return pdf.build();
}

async function renderWeeklyOpsPDF(weekDays, allBlocks, allLogs, mission, pdfTheme) {
  const dark = pdfTheme === 'dark';
  const pdf = new VectorPDF();
  pdf.addPage();

  const ac = dark ? [0, 1, 0.53] : [0.1, 0.37, 0.22];
  const tx = dark ? [0.9, 0.9, 0.93] : [0.12, 0.12, 0.12];
  const dim = dark ? [0.45, 0.45, 0.55] : [0.5, 0.5, 0.5];
  const statFn = dark ? 'statBoxDark' : 'statBox';

  const firstDate = weekDays[0], lastDate = weekDays[6];
  pdf.pageHeader('Operational Weekly Summary', 'Tactical Advisor Edition', `${fmtDateShort(firstDate)} - ${fmtDateShort(lastDate)}`, 1, 1, dark);

  const weekLogs = weekDays.map(d => allLogs.find(l => l.date === dateStr(d)) || null);
  const totH = weekLogs.reduce((s,l) => s + (l?.completedSec||0)/3600, 0);
  const totT = weekLogs.reduce((s,l) => s + (l?.totalTests||0), 0);
  const avgExec = weekLogs.filter(Boolean).length ? Math.round(weekLogs.filter(Boolean).reduce((s,l) => s + (l.execPct||0), 0) / weekLogs.filter(Boolean).length) : 0;
  const totBlocks = weekDays.reduce((s,d) => s + allBlocks.filter(b => b.date === dateStr(d)).length, 0);
  const testEff = totH > 0 ? totT / totH : 0;

  const sw = Math.floor((pdf.CW - 48) / 5);
  let sy = pdf.y;
  [{l:'TOTAL HOURS',v:totH.toFixed(1)+'h'},{l:'TOTAL TESTS',v:String(totT)},{l:'AVG EXECUTION',v:avgExec+'%'},{l:'TEST EFF/HR',v:testEff.toFixed(1)},{l:'BLOCKS',v:String(totBlocks)}]
    .forEach((s,i) => pdf[statFn](pdf.M + i*(sw+12), sy - 42, sw, 42, s.l, s.v, ac));
  sy -= 54;

  // Executive summary
  const planHWeek = weekLogs.reduce((s,l) => s + (l?.plannedHours||0), 0);
  let advisory = avgExec >= 80 ? 'Execution on target.' : avgExec < 60 ? 'Execution below threshold.' : 'Moderate performance — room for improvement.';
  const execLines = [
    `Week of ${fmtDateShort(firstDate)} to ${fmtDateShort(lastDate)}`,
    `Total: ${totH.toFixed(1)}h, ${totT} tests, ${avgExec}% avg execution`,
    `Efficiency: ${testEff.toFixed(1)} tests/hr across ${totBlocks} blocks`,
    planHWeek > 0 ? `Planned: ${planHWeek.toFixed(1)}h | Actual: ${totH.toFixed(1)}h` : 'No planned hours set.',
    advisory,
    mission ? `Mission: ${Math.max(0, Math.ceil((new Date(mission.targetDate) - new Date()) / 86400000))}d remaining` : 'No active mission.',
  ];

  const advBg = dark ? [0.08, 0.08, 0.10] : [0.96, 0.96, 0.96];
  const advH = execLines.length * 10 + 16;
  pdf.rect(pdf.M, sy - advH, pdf.CW, advH, advBg, dark ? [0.18,0.18,0.24] : [0.85,0.85,0.85], 0.5);
  pdf.rect(pdf.M, sy - advH, 2, advH, ac);
  pdf.text('EXECUTIVE SUMMARY', pdf.M + 6, sy - 8, { size: 6, mono: true, bold: true, color: dim });
  execLines.forEach((line, i) => {
    pdf.text(line, pdf.M + 6, sy - 18 - i * 10, { size: 7, mono: true, color: tx });
  });
  sy -= advH + 14;

  // Bar chart: daily execution
  pdf.text('DAILY EXECUTION %', pdf.M, sy, { size: 7, mono: true, bold: true, color: dim });
  sy -= 6;
  const chartH = 55;
  const execData = weekDays.map(d => { const l = allLogs.find(l => l.date === dateStr(d)); return l?.execPct || 0; });
  const dayLabelsShort = weekDays.map(d => ['Su','Mo','Tu','We','Th','Fr','Sa'][d.getDay()]);
  pdf.barChart(pdf.M, sy - chartH, pdf.CW, chartH, execData, dayLabelsShort, { dark, accentColor: ac });
  sy -= chartH + 22;

  // 8x7 Heatmap matrix
  pdf.text('8x7 SUBJECT PERFORMANCE HEATMAP MATRIX', pdf.M, sy, { size: 7, mono: true, bold: true, color: dim });
  sy -= 6;

  const md = buildMatrixData(weekDays, allBlocks);
  const dayLabelsFull = weekDays.map(d => ({
    short: ['Su','Mo','Tu','We','Th','Fr','Sa'][d.getDay()],
    date: fmtDateShort(d)
  }));
  const matrixDataIndexed = {};
  SUBJECT_MATRIX_LABELS.forEach(subj => {
    matrixDataIndexed[subj] = weekDays.map((d, di) => md[subj]?.[dateStr(d)] || { hours: 0, tests: 0 });
  });

  pdf.heatmapMatrix(pdf.M, sy, SUBJECT_MATRIX_LABELS, dayLabelsFull, matrixDataIndexed, {
    dark,
    labelW: 48,
    cellW: Math.floor((pdf.CW - 48) / 7),
    cellH: Math.min(26, Math.floor((sy - pdf.M - 40) / 9))
  });

  pdf.pageFooter(`WEEK OF ${fmtDateShort(firstDate).toUpperCase()} - ${fmtDateShort(lastDate).toUpperCase()}`, dark);
  return pdf.build();
}

async function renderFullAnalyticalPDF() {
  const allBlocks = await dbGetAll('studyBlocks');
  const allLogs = (await dbGetAll('dailyLogs')).sort((a,b) => a.date.localeCompare(b.date));
  const allInts = await dbGetAll('interruptions');
  const allFatigue = await dbGetAll('fatigueHistory');
  const mission = state.mission;
  const pdfTheme = journalState.pdfTheme;
  const dark = pdfTheme === 'dark';

  const ac = dark ? [0, 1, 0.53] : [0.1, 0.37, 0.22];
  const tx = dark ? [0.9, 0.9, 0.93] : [0.12, 0.12, 0.12];
  const dim = dark ? [0.45, 0.45, 0.55] : [0.5, 0.5, 0.5];
  const statFn = dark ? 'statBoxDark' : 'statBox';

  const last7 = Array.from({length:7}, (_,i) => addDays(new Date(), -6+i));
  const last30 = allLogs.slice(-30);
  const subjectAnalytics = computeSubjectAnalytics(allBlocks);
  const md = buildMatrixData(last7, allBlocks);
  const totalPages = allLogs.length > 5 ? 3 : 2;

  const pdf = new VectorPDF();

  // === PAGE 1: Overview + Trends ===
  pdf.addPage();
  pdf.pageHeader('Full Analytical Report', 'Comprehensive Performance Analysis', today(), 1, totalPages, dark);

  const totH = last30.reduce((s,l) => s + (l.completedSec||0)/3600, 0);
  const totT = last30.reduce((s,l) => s + (l.totalTests||0), 0);
  const avgExec = last30.length ? Math.round(last30.reduce((s,l) => s + (l.execPct||0), 0) / last30.length) : 0;
  const eff = totH > 0 ? totT / totH : 0;

  let sy = pdf.y;
  const sw = Math.floor((pdf.CW - 36) / 4);
  [{l:'30-DAY HOURS',v:totH.toFixed(1)+'h'},{l:'30-DAY TESTS',v:String(totT)},{l:'AVG EXECUTION',v:avgExec+'%'},{l:'TEST EFF/HR',v:eff.toFixed(1)}]
    .forEach((s,i) => pdf[statFn](pdf.M + i*(sw+12), sy - 48, sw, 48, s.l, s.v, ac));
  sy -= 62;

  // Execution sparkline
  pdf.text('EXECUTION % TREND - LAST 30 DAYS', pdf.M, sy, { size: 7, mono: true, bold: true, color: dim });
  sy -= 6;
  const execData30 = last30.map(l => l.execPct || 0);
  if (execData30.length >= 2) {
    pdf.sparkline(pdf.M, sy - 70, pdf.CW, 65, execData30, { dark, color: ac, threshold: 80 });
  }
  sy -= 80;

  // Fatigue trend
  const fat14 = allFatigue.slice(-14);
  if (fat14.length >= 2) {
    pdf.text('FATIGUE INDEX TREND - LAST 14 DAYS', pdf.M, sy, { size: 7, mono: true, bold: true, color: dim });
    sy -= 6;
    pdf.sparkline(pdf.M, sy - 50, pdf.CW, 45, fat14.map(f => f.fatigue), { dark, color: dark ? [1, 0.65, 0] : [0.85, 0.53, 0] });
    sy -= 60;
  }

  // Mission gauge
  if (mission) {
    const dL = Math.max(1, Math.ceil((new Date(mission.targetDate) - new Date()) / 86400000));
    const compH = allLogs.reduce((s,l) => s + (l.completedSec||0)/3600, 0);
    const remH = Math.max(0, mission.requiredHours - compH);
    const cap = last30.length > 0 ? last30.reduce((s,l) => s + (l.completedSec||0)/3600, 0) / last30.length : 3;
    const tpi = dL > 0 ? remH / (dL * cap) : 99;
    const tpiCol = tpi > 1.2 ? [1,0.24,0.24] : tpi > 1 ? [1,0.47,0] : tpi > 0.8 ? [1,0.65,0] : ac;

    pdf.rect(pdf.M, sy - 38, pdf.CW, 38, dark ? [0.07,0.07,0.09] : [0.96,0.96,0.96], dark ? [0.18,0.18,0.24] : [0.85,0.85,0.85], 0.5);
    pdf.text('MISSION PRESSURE ENGINE', pdf.M + 8, sy - 8, { size: 6.5, mono: true, bold: true, color: dim });
    pdf.text('TPI ' + tpi.toFixed(2), pdf.M + 8, sy - 28, { size: 16, mono: true, bold: true, color: tpiCol });
    pdf.text(`${mission.name||'Mission'} | ${dL}d remaining | ${remH.toFixed(0)}h outstanding | Cap ${cap.toFixed(1)}h/d`, pdf.CW + pdf.M - 8, sy - 25, { size: 7, mono: true, color: dim, align: 'right' });
    sy -= 50;
  }

  pdf.pageFooter('PAGE 1 OF ' + totalPages, dark);

  // === PAGE 2: Subject + Heatmap ===
  pdf.addPage();
  pdf.pageHeader('Subject Intelligence & Heatmap', 'Subject x Day Performance Matrix', today(), 2, totalPages, dark);
  sy = pdf.y;

  // Subject cards
  if (subjectAnalytics.subjects.length > 0) {
    pdf.text('SUBJECT DISTRIBUTION ANALYTICS', pdf.M, sy, { size: 7, mono: true, bold: true, color: dim });
    sy -= 8;
    const cardW = Math.floor((pdf.CW - 24) / Math.min(subjectAnalytics.subjects.length, 4));
    subjectAnalytics.subjects.slice(0, 8).forEach((s, i) => {
      const row = Math.floor(i / 4), col = i % 4;
      const cx = pdf.M + col * (cardW + 8);
      const cy = sy - row * 48;
      const bg = dark ? [0.08, 0.08, 0.10] : [0.95, 0.95, 0.95];
      pdf.rect(cx, cy - 40, cardW, 40, bg, dark ? [0.18,0.18,0.24] : [0.85,0.85,0.85], 0.5);
      pdf.smartText(s.name, cx + 4, cy - 8, { size: 7.5, bold: true, mono: true, color: tx, maxWidth: cardW - 8 });
      pdf.text(`${s.hours.toFixed(1)}h | ${s.tests}T | ${s.efficiency.toFixed(1)}/hr`, cx + 4, cy - 22, { size: 6, mono: true, color: dim });
      pdf.text(s.dominance.toFixed(0) + '%', cx + cardW - 6, cy - 8, { size: 9, mono: true, bold: true, color: ac, align: 'right' });
      // Dominance bar
      const barW = cardW - 8;
      pdf.rect(cx + 4, cy - 38, barW, 3, dark ? [0.12,0.12,0.15] : [0.88,0.88,0.88]);
      pdf.rect(cx + 4, cy - 38, Math.round(s.dominance / 100 * barW), 3, ac);
    });
    sy -= Math.ceil(Math.min(subjectAnalytics.subjects.length, 8) / 4) * 48 + 8;
  }

  // Neglected
  if (subjectAnalytics.neglected.length > 0) {
    pdf.rect(pdf.M, sy - 18, pdf.CW, 18, dark ? [0.12,0.04,0.04] : [1,0.94,0.94], dark ? [0.5,0.15,0.15] : [0.85,0.5,0.5], 0.5);
    pdf.text('NEGLECTED: ' + subjectAnalytics.neglected.join(' | '), pdf.M + 6, sy - 12, { size: 7, mono: true, bold: true, color: [0.85, 0.2, 0.15] });
    sy -= 28;
  }

  // Heatmap
  pdf.text('8x7 SUBJECT x DAY HEATMAP MATRIX - Last 7 Days', pdf.M, sy, { size: 7, mono: true, bold: true, color: dim });
  sy -= 6;

  const dayLabelsFull = last7.map(d => ({
    short: ['Su','Mo','Tu','We','Th','Fr','Sa'][d.getDay()],
    date: fmtDateShort(d)
  }));
  const matrixDataIndexed = {};
  SUBJECT_MATRIX_LABELS.forEach(subj => {
    matrixDataIndexed[subj] = last7.map(d => md[subj]?.[dateStr(d)] || { hours:0, tests:0 });
  });

  pdf.heatmapMatrix(pdf.M, sy, SUBJECT_MATRIX_LABELS, dayLabelsFull, matrixDataIndexed, {
    dark,
    labelW: 48,
    cellW: Math.floor((pdf.CW - 48) / 7),
    cellH: Math.min(28, Math.floor((sy - pdf.M - 30) / 9))
  });

  pdf.pageFooter('PAGE 2 OF ' + totalPages, dark);

  // === PAGE 3: Narrative (if enough data) ===
  if (allLogs.length >= 5) {
    pdf.addPage();
    pdf.pageHeader('Advisor Full Narrative', '30-Day Advisory Assessment', today(), 3, totalPages, dark);
    sy = pdf.y;

    const s = dateStr(addDays(new Date(), -30)), e = today();
    const rangeLogs = allLogs.filter(l => l.date >= s && l.date <= e);
    const rm = computeRangeMetrics(rangeLogs, allBlocks, allInts, allFatigue, s, e);
    const prevS = dateStr(addDays(parseDate(s), -31)), prevE = dateStr(addDays(parseDate(s), -1));
    const pm = computeRangeMetrics(allLogs.filter(l => l.date >= prevS && l.date <= prevE), allBlocks, allInts, allFatigue, prevS, prevE);
    const lm = computeRangeMetrics(allLogs, allBlocks, allInts, allFatigue, '', '');

    if (rm) {
      // Build narrative text (strip HTML)
      const narrativeHTML = buildHumanReport(rm, pm, null, lm, s, e, 30, subjectAnalytics, last7, md);
      const stripHTML = html => html.replace(/<[^>]+>/g, '').replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/\s+/g, ' ');
      const sections = narrativeHTML.match(/<div class="report-paragraph[^>]*>[\s\S]*?<\/div>/g) || [];

      const sectionColors = [ac, dark?[0.23,0.51,0.97]:[0.15,0.33,0.6], dark?[1,0.65,0]:[0.72,0.45,0], dark?[1,0.65,0]:[0.72,0.45,0], ac];

      sections.forEach((section, si) => {
        if (sy < pdf.M + 60) {
          pdf.addPage();
          sy = pdf.H - pdf.M - 20;
        }
        const tagMatch = section.match(/report-paragraph-tag">([^<]+)/);
        const tag = tagMatch ? tagMatch[1] : '';
        const textMatch = section.match(/<\/span>([\s\S]+)<\/div>/);
        const rawText = textMatch ? stripHTML(textMatch[1]).trim() : '';
        if (!rawText) return;

        // Section marker
        const sColor = sectionColors[si] || ac;
        pdf.rect(pdf.M, sy - 1, 3, 1, sColor);
        pdf.text(tag, pdf.M + 8, sy, { size: 6.5, mono: true, bold: true, color: sColor });
        pdf.line(pdf.M, sy - 3, pdf.M + pdf.CW, sy - 3, dark ? [0.18,0.18,0.24] : [0.9,0.9,0.9], 0.3);
        sy -= 12;

        // Word-wrapped paragraph
        sy = pdf.textBlock(rawText, pdf.M + 4, sy, pdf.CW - 8, { size: 8, color: tx, lineHeight: 12 });
        sy -= 10;
      });
    }

    pdf.pageFooter('PAGE 3 OF ' + totalPages, dark);
  }

  return pdf.build();
}

// --- Trigger functions ---
async function triggerJournalGenerate() {
  const prog = el('jrnlProgress'), progTxt = el('jrnlProgressText');
  if (prog) prog.classList.add('active');
  const btn = el('jrnlGenerateBtn');
  if (btn) btn.disabled = true;

  try {
    const allBlocks = state.blocks;
    const allLogs = await dbGetAll('dailyLogs');
    const mission = state.mission;

    if (journalState.mode === 'day') {
      if (progTxt) progTxt.textContent = 'Rendering daily operational PDF...';
      await new Promise(r => setTimeout(r, 10));
      const ds = journalState.dayDate;
      const blocks = allBlocks.filter(b => b.date === ds);
      const log = allLogs.find(l => l.date === ds) || null;
      const pdfBytes = await renderDailyOpsPDF(parseDate(ds), blocks, log, mission, state.fatigueIndex, journalState.pdfTheme);
      downloadPDF(pdfBytes, `execution-journal-${ds}.pdf`);
    } else {
      if (progTxt) progTxt.textContent = 'Rendering weekly operational PDF...';
      await new Promise(r => setTimeout(r, 10));
      const days = getWeekDays(journalState.weekRefDate, journalState.weekStartDay);
      const pdfBytes = await renderWeeklyOpsPDF(days, allBlocks, allLogs, mission, journalState.pdfTheme);
      downloadPDF(pdfBytes, `execution-weekly-journal-${dateStr(days[0])}.pdf`);
    }
  } catch(err) { showToast('PDF error: ' + err.message); console.error(err); }

  if (prog) prog.classList.remove('active');
  if (btn) btn.disabled = false;
}

async function exportFullAnalyticalPDF() {
  const prog = el('jrnlProgress'), progTxt = el('jrnlProgressText');
  if (prog) prog.classList.add('active');
  const btns = document.querySelectorAll('[onclick*="exportFullAnalyticalPDF"]');
  btns.forEach(b => b.disabled = true);

  try {
    if (progTxt) progTxt.textContent = 'Generating full analytical report...';
    await new Promise(r => setTimeout(r, 10));
    const pdfBytes = await renderFullAnalyticalPDF();
    downloadPDF(pdfBytes, `execution-analytical-report-${today()}.pdf`);
  } catch(err) { showToast('Analytical PDF error: ' + err.message); console.error(err); }

  if (prog) prog.classList.remove('active');
  btns.forEach(b => b.disabled = false);
}

function exportOperationalDayPDF() {
  journalState.dayDate = today();
  journalState.mode = 'day';
  journalState.pdfTheme = 'light';
  triggerJournalGenerate();
}

function exportOperationalWeekPDF() {
  journalState.weekRefDate = today();
  journalState.mode = 'week';
  journalState.weekStartDay = 1;
  triggerJournalGenerate();
}

// ================================================================
// VECTOR PDF WRITER — Production-grade offline PDF 1.4 generator
// Outputs real text, vector shapes, proper A4. No raster dependency.
// Persian handled via high-DPI micro-render fallback for non-Latin.
// ================================================================
class VectorPDF {
  constructor() {
    this.pages = [];
    this.W = 595.28; // A4 width in points
    this.H = 841.89; // A4 height in points
    this.M = 40;     // margin
    this.CW = 595.28 - 80; // content width
    this.fonts = {
      'Helvetica': { ref: null, name: 'Helvetica' },
      'Helvetica-Bold': { ref: null, name: 'Helvetica-Bold' },
      'Courier': { ref: null, name: 'Courier' },
      'Courier-Bold': { ref: null, name: 'Courier-Bold' },
    };
    this._currentPage = null;
    this._imageResources = [];
  }

  addPage() {
    const page = {
      streams: [],
      images: [],
      _y: this.H - this.M,
    };
    this.pages.push(page);
    this._currentPage = page;
    return this;
  }

  get pg() { return this._currentPage; }
  get y() { return this.pg._y; }
  set y(v) { this.pg._y = v; }

  // --- Drawing primitives ---
  rect(x, y, w, h, fill, stroke, lineWidth) {
    let s = 'q\n';
    if (lineWidth) s += `${lineWidth} w\n`;
    if (fill) s += `${this._color(fill)} rg\n`;
    if (stroke) s += `${this._color(stroke)} RG\n`;
    s += `${this._n(x)} ${this._n(y)} ${this._n(w)} ${this._n(h)} re\n`;
    if (fill && stroke) s += 'B\n';
    else if (fill) s += 'f\n';
    else if (stroke) s += 'S\n';
    s += 'Q\n';
    this.pg.streams.push(s);
    return this;
  }

  line(x1, y1, x2, y2, color, lineWidth) {
    let s = 'q\n';
    s += `${lineWidth || 0.5} w\n`;
    s += `${this._color(color || [0.3,0.3,0.3])} RG\n`;
    s += `${this._n(x1)} ${this._n(y1)} m ${this._n(x2)} ${this._n(y2)} l S\nQ\n`;
    this.pg.streams.push(s);
    return this;
  }

  dashedLine(x1, y1, x2, y2, color, lineWidth, dashOn, dashOff) {
    let s = 'q\n';
    s += `[${dashOn||3} ${dashOff||3}] 0 d\n`;
    s += `${lineWidth || 0.5} w\n`;
    s += `${this._color(color || [0.5,0.5,0.5])} RG\n`;
    s += `${this._n(x1)} ${this._n(y1)} m ${this._n(x2)} ${this._n(y2)} l S\nQ\n`;
    this.pg.streams.push(s);
    return this;
  }

  // --- Text primitives (Latin/ASCII only — uses built-in PDF fonts) ---
  text(str, x, y, opts = {}) {
    if (!str || str.length === 0) return this;
    const font = opts.bold ? (opts.mono ? 'Courier-Bold' : 'Helvetica-Bold') : (opts.mono ? 'Courier' : 'Helvetica');
    const size = opts.size || 9;
    const color = opts.color || [0, 0, 0];
    const align = opts.align || 'left';

    // Filter to printable ASCII — non-Latin chars become placeholder
    const safe = this._safeStr(str);

    let tx = x;
    if (align === 'center') tx = x - this._approxWidth(safe, font, size) / 2;
    else if (align === 'right') tx = x - this._approxWidth(safe, font, size);

    let s = 'q\nBT\n';
    s += `/${font} ${size} Tf\n`;
    s += `${this._color(color)} rg\n`;
    s += `${this._n(tx)} ${this._n(y)} Td\n`;
    s += `(${this._escPdf(safe)}) Tj\n`;
    s += 'ET\nQ\n';
    this.pg.streams.push(s);
    return this;
  }

  // Word-wrapped text block — returns final y position
  textBlock(str, x, y, maxWidth, opts = {}) {
    if (!str) return y;
    const size = opts.size || 9;
    const lineH = opts.lineHeight || size * 1.6;
    const font = opts.bold ? (opts.mono ? 'Courier-Bold' : 'Helvetica-Bold') : (opts.mono ? 'Courier' : 'Helvetica');
    const safe = this._safeStr(str);
    const words = safe.split(' ');
    let line = '', cy = y;

    for (const word of words) {
      const test = line + (line ? ' ' : '') + word;
      if (this._approxWidth(test, font, size) > maxWidth && line) {
        this.text(line, x, cy, opts);
        cy -= lineH;
        line = word;
        if (cy < this.M + 30) {
          this.addPage();
          cy = this.H - this.M - 20;
        }
      } else {
        line = test;
      }
    }
    if (line) { this.text(line, x, cy, opts); cy -= lineH; }
    return cy;
  }

  // --- Persian/RTL text via micro-image embedding ---
  persianText(str, x, y, opts = {}) {
    if (!str || str.length === 0) return this;
    const size = opts.size || 9;
    const maxW = opts.maxWidth || 200;
    const color = opts.color || [0.1, 0.1, 0.1];
    const bold = opts.bold || false;

    // Render on offscreen canvas at 3x for quality
    const scale = 3;
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const fontSize = size * scale;
    ctx.font = `${bold ? 'bold ' : ''}${fontSize}px 'Segoe UI', 'Tahoma', 'Arial', sans-serif`;
    const measured = ctx.measureText(str);
    const cw = Math.min(Math.ceil(measured.width) + 4, maxW * scale);
    const ch = Math.ceil(fontSize * 1.4);
    canvas.width = cw;
    canvas.height = ch;

    // Transparent background
    ctx.clearRect(0, 0, cw, ch);
    ctx.font = `${bold ? 'bold ' : ''}${fontSize}px 'Segoe UI', 'Tahoma', 'Arial', sans-serif`;
    ctx.fillStyle = `rgb(${Math.round(color[0]*255)},${Math.round(color[1]*255)},${Math.round(color[2]*255)})`;
    ctx.textAlign = opts.align === 'center' ? 'center' : opts.align === 'right' ? 'right' : 'left';
    ctx.textBaseline = 'top';
    const textX = opts.align === 'center' ? cw / 2 : opts.align === 'right' ? cw - 2 : 2;
    ctx.fillText(str, textX, 2);

    // Convert to PNG data
    const dataUrl = canvas.toDataURL('image/png');
    const pdfW = cw / scale;
    const pdfH = ch / scale;
    const imgIdx = this.pg.images.length;
    this.pg.images.push({ dataUrl, x, y: y - pdfH + size * 0.3, w: pdfW, h: pdfH });
    return this;
  }

  // Smart text — auto-detects Persian vs Latin
  smartText(str, x, y, opts = {}) {
    if (!str) return this;
    if (/[\u0600-\u06FF\u0750-\u077F\uFB50-\uFDFF\uFE70-\uFEFF]/.test(str)) {
      return this.persianText(str, x, y, opts);
    }
    return this.text(str, x, y, opts);
  }

  // --- Stat box helper ---
  statBox(x, y, w, h, label, value, accentColor) {
    const ac = accentColor || [0, 0.8, 0.4];
    this.rect(x, y, w, h, [0.96, 0.96, 0.96], [0.85, 0.85, 0.85], 0.5);
    this.rect(x, y + h - 2, w, 2, ac);
    this.text(String(value), x + 8, y + h - 18, { size: 14, bold: true, mono: true, color: [0.1, 0.1, 0.1] });
    this.text(label, x + 8, y + 8, { size: 6.5, mono: true, color: [0.5, 0.5, 0.5] });
    return this;
  }

  statBoxDark(x, y, w, h, label, value, accentColor) {
    const ac = accentColor || [0, 1, 0.53];
    this.rect(x, y, w, h, [0.10, 0.10, 0.12], [0.18, 0.18, 0.22], 0.5);
    this.rect(x, y + h - 2, w, 2, ac);
    this.text(String(value), x + 8, y + h - 18, { size: 14, bold: true, mono: true, color: ac });
    this.text(label, x + 8, y + 8, { size: 6.5, mono: true, color: [0.45, 0.45, 0.55] });
    return this;
  }

  // --- Page header/footer ---
  pageHeader(title, subtitle, dateStr, pageNum, totalPages, dark) {
    const headerH = 52;
    if (dark) {
      this.rect(0, this.H - headerH, this.W, headerH, [0.04, 0.04, 0.05]);
      this.rect(0, this.H - headerH, 3, headerH, [0, 1, 0.53]);
      this.text('EXECUTION ENGINE', this.M, this.H - 18, { size: 10, bold: true, mono: true, color: [0, 1, 0.53] });
      this.text(subtitle || 'TACTICAL ADVISOR EDITION', this.M, this.H - 32, { size: 7, mono: true, color: [0.35, 0.35, 0.45] });
      this.text(dateStr || '', this.W - this.M, this.H - 18, { size: 11, bold: true, mono: true, color: [0.9, 0.9, 0.9], align: 'right' });
      this.text(title.toUpperCase(), this.W - this.M, this.H - 30, { size: 7, mono: true, color: [0.45, 0.45, 0.55], align: 'right' });
      this.text(`PAGE ${pageNum} / ${totalPages}`, this.W - this.M, this.H - 42, { size: 6.5, mono: true, color: [0.35, 0.35, 0.45], align: 'right' });
    } else {
      this.rect(0, this.H - headerH, this.W, headerH, [0.1, 0.1, 0.1]);
      this.rect(0, this.H - headerH, 3, headerH, [0.1, 0.37, 0.22]);
      this.text('EXECUTION ENGINE', this.M, this.H - 18, { size: 10, bold: true, mono: true, color: [1, 1, 1] });
      this.text(subtitle || 'TACTICAL ADVISOR EDITION', this.M, this.H - 32, { size: 7, mono: true, color: [0.7, 0.7, 0.7] });
      this.text(dateStr || '', this.W - this.M, this.H - 18, { size: 11, bold: true, mono: true, color: [1, 1, 1], align: 'right' });
      this.text(title.toUpperCase(), this.W - this.M, this.H - 30, { size: 7, mono: true, color: [0.7, 0.7, 0.7], align: 'right' });
      this.text(`PAGE ${pageNum} / ${totalPages}`, this.W - this.M, this.H - 42, { size: 6.5, mono: true, color: [0.6, 0.6, 0.6], align: 'right' });
    }
    this.pg._y = this.H - headerH - 16;
    return this;
  }

  pageFooter(label, dark) {
    const fy = this.M - 8;
    this.line(this.M, fy + 14, this.W - this.M, fy + 14, dark ? [0.18, 0.18, 0.22] : [0.85, 0.85, 0.85], 0.5);
    this.text('EXECUTION ENGINE · TACTICAL ADVISOR EDITION', this.M, fy + 4, { size: 6, mono: true, color: dark ? [0.3, 0.3, 0.4] : [0.65, 0.65, 0.65] });
    if (label) this.text(label, this.W - this.M, fy + 4, { size: 6, mono: true, color: dark ? [0, 0.8, 0.4] : [0.2, 0.5, 0.3], align: 'right' });
    return this;
  }

  // --- Table helper ---
  table(x, y, cols, rows, opts = {}) {
    const dark = opts.dark || false;
    const rowH = opts.rowH || 18;
    const headH = opts.headH || 20;
    const headBg = dark ? [0.10, 0.10, 0.14] : [0.12, 0.12, 0.12];
    const headColor = dark ? [0, 0.85, 0.45] : [1, 1, 1];
    const borderColor = dark ? [0.18, 0.18, 0.24] : [0.82, 0.82, 0.82];
    const altBg = dark ? [0.07, 0.07, 0.09] : [0.97, 0.97, 0.97];
    const cellBg = dark ? [0.05, 0.05, 0.06] : [1, 1, 1];
    const textColor = dark ? [0.85, 0.85, 0.9] : [0.15, 0.15, 0.15];
    const dimColor = dark ? [0.45, 0.45, 0.55] : [0.5, 0.5, 0.5];
    const totalW = cols.reduce((s, c) => s + c.w, 0);

    // Header row
    this.rect(x, y - headH, totalW, headH, headBg, borderColor, 0.5);
    let cx = x;
    cols.forEach(col => {
      this.text(col.label, cx + 4, y - headH + 6, { size: 6.5, mono: true, bold: true, color: headColor });
      cx += col.w;
    });

    // Data rows
    let ry = y - headH;
    rows.forEach((row, ri) => {
      ry -= rowH;
      if (ry < this.M + 30) {
        this.addPage();
        ry = this.H - this.M - 20;
        // Re-draw header on new page
        this.rect(x, ry + rowH, totalW, headH, headBg, borderColor, 0.5);
        cx = x;
        cols.forEach(col => {
          this.text(col.label, cx + 4, ry + rowH - headH + 6, { size: 6.5, mono: true, bold: true, color: headColor });
          cx += col.w;
        });
        ry -= headH;
      }
      const bg = ri % 2 === 0 ? cellBg : altBg;
      this.rect(x, ry, totalW, rowH, bg, borderColor, 0.3);
      cx = x;
      cols.forEach((col, ci) => {
        const val = row[ci] || '';
        const isCheckbox = col.type === 'checkbox';
        if (isCheckbox) {
          const cbx = cx + (col.w - 8) / 2, cby = ry + (rowH - 8) / 2;
          this.rect(cbx, cby, 8, 8, null, borderColor, 0.8);
          if (val === true || val === '✓') {
            this.line(cbx + 1, cby + 4, cbx + 3, cby + 1, dark ? [0, 0.9, 0.5] : [0.1, 0.5, 0.2], 1.2);
            this.line(cbx + 3, cby + 1, cbx + 7, cby + 7, dark ? [0, 0.9, 0.5] : [0.1, 0.5, 0.2], 1.2);
          }
        } else {
          const cellColor = col.colorFn ? col.colorFn(val, row) : (col.dim ? dimColor : textColor);
          const truncated = this._truncPt(String(val), col.w - 8, col.bold ? (col.mono ? 'Courier-Bold' : 'Helvetica-Bold') : (col.mono ? 'Courier' : 'Helvetica'), col.size || 7.5);
          // Check if Persian
          if (/[\u0600-\u06FF]/.test(String(val))) {
            this.persianText(String(val), cx + 4, ry + rowH - 6, { size: col.size || 7.5, color: cellColor, bold: col.bold, maxWidth: col.w - 8 });
          } else {
            this.text(truncated, cx + 4, ry + (rowH * 0.35), { size: col.size || 7.5, mono: col.mono, bold: col.bold, color: cellColor });
          }
        }
        cx += col.w;
      });
    });
    // Outer border
    const totalH = headH + rows.length * rowH;
    this.rect(x, y - totalH, totalW, totalH, null, borderColor, 1);
    return ry;
  }

  // --- Heatmap matrix ---
  heatmapMatrix(x, y, subjects, dayLabels, data, opts = {}) {
    const dark = opts.dark || false;
    const col0W = opts.labelW || 52;
    const cellW = opts.cellW || Math.floor((this.CW - col0W) / dayLabels.length);
    const cellH = opts.cellH || Math.floor(Math.min(28, (y - this.M - 60) / (subjects.length + 1)));
    const borderColor = dark ? [0.18, 0.18, 0.24] : [0.8, 0.8, 0.8];
    const headBg = dark ? [0.10, 0.10, 0.14] : [0.12, 0.12, 0.12];
    const headText = dark ? [0, 0.85, 0.45] : [1, 1, 1];
    const labelText = dark ? [0.55, 0.55, 0.65] : [0.35, 0.35, 0.35];

    // Find max for color scaling
    let maxVal = 0;
    subjects.forEach(subj => dayLabels.forEach((_, di) => {
      const v = data[subj]?.[di]?.hours || 0;
      if (v > maxVal) maxVal = v;
    }));

    const heatColor = (hours) => {
      if (maxVal === 0 || hours === 0) return dark ? [0.06, 0.06, 0.08] : [0.98, 0.98, 0.98];
      const ratio = Math.min(1, hours / maxVal);
      if (dark) {
        return [0, 0.15 + ratio * 0.72, 0.12 + ratio * 0.4];
      } else {
        return [0.92 - ratio * 0.75, 0.92 - ratio * 0.52, 1 - ratio * 0.1];
      }
    };
    const heatTextColor = (hours) => {
      if (maxVal === 0 || hours === 0) return dark ? [0.3, 0.3, 0.4] : [0.7, 0.7, 0.7];
      const ratio = hours / maxVal;
      if (ratio > 0.55) return dark ? [0, 0, 0.05] : [1, 1, 1];
      return dark ? [0.8, 0.8, 0.85] : [0.15, 0.15, 0.15];
    };

    // Header row: corner + day labels
    this.rect(x, y - cellH, col0W, cellH, headBg, borderColor, 0.5);
    this.text('SUBJ / DAY', x + 3, y - cellH + 5, { size: 5, mono: true, color: dark ? [0.35, 0.35, 0.45] : [0.7, 0.7, 0.7] });
    dayLabels.forEach((dl, di) => {
      const dx = x + col0W + di * cellW;
      this.rect(dx, y - cellH, cellW, cellH, headBg, borderColor, 0.5);
      this.text(dl.short, dx + cellW / 2, y - cellH + (cellH > 22 ? 10 : 5), { size: 7, mono: true, bold: true, color: headText, align: 'center' });
      if (cellH > 22 && dl.date) {
        this.text(dl.date, dx + cellW / 2, y - cellH + 4, { size: 5.5, mono: true, color: dark ? [0.4, 0.4, 0.5] : [0.6, 0.6, 0.6], align: 'center' });
      }
    });

    // Subject rows
    subjects.forEach((subj, si) => {
      const ry = y - cellH - (si + 1) * cellH;
      // Label cell
      this.rect(x, ry, col0W, cellH, dark ? [0.08, 0.08, 0.10] : [0.94, 0.94, 0.94], borderColor, 0.5);
      this.smartText(subj, x + 3, ry + cellH * 0.45, { size: 7, bold: true, mono: true, color: labelText, maxWidth: col0W - 6 });

      // Data cells
      dayLabels.forEach((dl, di) => {
        const dx = x + col0W + di * cellW;
        const cell = data[subj]?.[di] || { hours: 0, tests: 0 };
        const bgC = heatColor(cell.hours);
        const txC = heatTextColor(cell.hours);
        this.rect(dx, ry, cellW, cellH, bgC, borderColor, 0.3);
        const display = cell.hours > 0 ? cell.hours.toFixed(1) + 'h' : '-';
        this.text(display, dx + cellW / 2, ry + cellH * (cellH > 22 ? 0.55 : 0.38), { size: 7, mono: true, bold: cell.hours > 0, color: txC, align: 'center' });
        if (cellH > 22 && cell.tests > 0) {
          this.text(cell.tests + 'T', dx + cellW / 2, ry + 4, { size: 5.5, mono: true, color: txC, align: 'center' });
        }
      });
    });

    // Outer border
    const totalH = (subjects.length + 1) * cellH;
    const totalW = col0W + dayLabels.length * cellW;
    this.rect(x, y - totalH, totalW, totalH, null, borderColor, 1.5);
    return y - totalH - 8;
  }

  // --- Bar chart ---
  barChart(x, y, w, h, data, labels, opts = {}) {
    const dark = opts.dark || false;
    const barGap = 3;
    const barW = Math.floor((w - barGap * data.length) / data.length);
    const maxVal = Math.max(...data, 1);
    const axisColor = dark ? [0.2, 0.2, 0.28] : [0.8, 0.8, 0.8];
    const accentColor = opts.accentColor || (dark ? [0, 1, 0.53] : [0.1, 0.37, 0.22]);

    // Axis
    this.line(x, y, x + w, y, axisColor, 0.5);

    data.forEach((v, i) => {
      const bh = Math.round((v / maxVal) * (h - 14));
      const bx = x + i * (barW + barGap);
      const col = v >= 85 ? (dark ? [0, 0.9, 0.45] : [0.1, 0.6, 0.3]) :
                  v >= 60 ? (dark ? [1, 0.65, 0] : [0.85, 0.55, 0]) :
                  v > 0  ? (dark ? [1, 0.3, 0.25] : [0.85, 0.2, 0.15]) :
                           (dark ? [0.15, 0.15, 0.2] : [0.88, 0.88, 0.88]);
      this.rect(bx, y, barW, bh, col);
      if (labels && labels[i]) {
        this.text(labels[i], bx + barW / 2, y - 6, { size: 5.5, mono: true, color: dark ? [0.4, 0.4, 0.5] : [0.5, 0.5, 0.5], align: 'center' });
      }
      if (v > 0) {
        this.text(String(Math.round(v)), bx + barW / 2, y + bh + 3, { size: 5, mono: true, color: dark ? [0.5, 0.5, 0.6] : [0.4, 0.4, 0.4], align: 'center' });
      }
    });
    return this;
  }

  // --- Sparkline ---
  sparkline(x, y, w, h, data, opts = {}) {
    if (!data || data.length < 2) return this;
    const dark = opts.dark || false;
    const color = opts.color || (dark ? [0, 1, 0.53] : [0.1, 0.37, 0.22]);
    const maxV = Math.max(...data, 0.01);
    const stepX = w / (data.length - 1);

    let path = '';
    data.forEach((v, i) => {
      const px = x + i * stepX;
      const py = y + (1 - v / maxV) * h;
      path += `${this._n(px)} ${this._n(py)} ${i === 0 ? 'm' : 'l'}\n`;
    });
    let s = `q\n${color.join(' ')} RG\n1.2 w\n${path}S\nQ\n`;
    this.pg.streams.push(s);

    // Threshold line at 80%
    if (opts.threshold) {
      const ty = y + (1 - opts.threshold / maxV) * h;
      this.dashedLine(x, ty, x + w, ty, dark ? [0.8, 0.2, 0.2] : [0.85, 0.15, 0.15], 0.4, 2, 2);
    }
    return this;
  }

  // --- Internal helpers ---
  _color(c) {
    if (Array.isArray(c)) return c.map(v => this._n(v)).join(' ');
    return '0 0 0';
  }
  _n(v) { return parseFloat(v).toFixed(2); }
  _escPdf(str) { return str.replace(/\\/g, '\\\\').replace(/\(/g, '\\(').replace(/\)/g, '\\)'); }
  _safeStr(str) {
    let out = '';
    for (let i = 0; i < str.length; i++) {
      const c = str.charCodeAt(i);
      if (c >= 32 && c <= 126) out += str[i];
      else if (c === 8212 || c === 8211) out += '-';
      else if (c === 8216 || c === 8217) out += "'";
      else if (c === 8220 || c === 8221) out += '"';
      else if (c === 8230) out += '...';
      else out += ' ';
    }
    return out;
  }
  _approxWidth(str, font, size) {
    const isM = font.startsWith('Courier');
    const charW = isM ? size * 0.6 : size * 0.52;
    return str.length * charW;
  }
  _truncPt(str, maxPt, font, size) {
    if (this._approxWidth(str, font, size) <= maxPt) return str;
    while (str.length > 0 && this._approxWidth(str + '...', font, size) > maxPt) str = str.slice(0, -1);
    return str + '...';
  }

  // === PDF BINARY ASSEMBLY ===
  build() {
    const enc = new TextEncoder();
    const parts = [];
    let pos = 0;
    const offsets = {};

    const pushStr = (s) => { const b = enc.encode(s); parts.push(b); pos += b.length; };
    const pushBytes = (b) => { parts.push(b); pos += b.length; };
    const mark = (n) => { offsets[n] = pos; };

    // Collect all images from all pages
    const allImages = [];
    this.pages.forEach((pg, pi) => {
      pg.images.forEach((img, ii) => {
        allImages.push({ pageIdx: pi, imgIdx: ii, ...img });
      });
    });

    // Decode PNG dataUrls to raw image data for embedding
    const imageDataArr = allImages.map(img => {
      const b64 = img.dataUrl.split(',')[1];
      const bin = atob(b64);
      const bytes = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
      // PNG decode is complex. Embed as JPEG instead for simplicity
      // Re-render the micro-canvas as JPEG
      return { bytes, isPNG: img.dataUrl.startsWith('data:image/png') };
    });

    // Re-render as JPEG by drawing onto canvas
    const jpegDataArrays = allImages.map((img, idx) => {
      const tmpCanvas = document.createElement('canvas');
      const tmpImg = new Image();
      // Synchronous approach: just use the PNG bytes as-is with FlateDecode
      // Actually for simplicity: embed as inline image or use DCTDecode
      // We'll convert via canvas synchronously using a trick
      return null; // Will handle below
    });

    // Simpler approach: pre-convert all images to JPEG synchronously
    // Since persianText creates canvas elements, we re-render them as JPEG data
    const processedImages = [];
    const convertPromises = allImages.map((img, idx) => {
      return new Promise(resolve => {
        const tmpImg = new Image();
        tmpImg.onload = () => {
          const c = document.createElement('canvas');
          c.width = tmpImg.width; c.height = tmpImg.height;
          const ctx = c.getContext('2d');
          // White background for JPEG (no transparency)
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(0, 0, c.width, c.height);
          ctx.drawImage(tmpImg, 0, 0);
          c.toBlob(blob => {
            const reader = new FileReader();
            reader.onload = () => {
              const b64 = reader.result.split(',')[1];
              const bin = atob(b64);
              const bytes = new Uint8Array(bin.length);
              for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
              processedImages[idx] = { bytes, w: tmpImg.width, h: tmpImg.height, ...img };
              resolve();
            };
            reader.readAsDataURL(blob);
          }, 'image/jpeg', 0.95);
        };
        tmpImg.src = img.dataUrl;
      });
    });

    // This must be async — return a Promise
    return Promise.all(convertPromises).then(() => {
      return this._assemblePDF(pushStr, pushBytes, mark, parts, pos, offsets, processedImages);
    });
  }

  _assemblePDF(pushStr, pushBytes, mark, parts, pos, offsets, processedImages) {
    // Reassign pos tracking since closures captured initial values
    let currentPos = pos;
    const _pushStr = (s) => { const b = new TextEncoder().encode(s); parts.push(b); currentPos += b.length; };
    const _pushBytes = (b) => { parts.push(b); currentPos += b.length; };
    const _mark = (n) => { offsets[n] = currentPos; };

    const N = this.pages.length;
    const fontNames = Object.keys(this.fonts);

    // Object numbering:
    // 1 = Catalog, 2 = Pages, 3..6 = Fonts (4 fonts)
    // Per page: pageObj, contentsObj, then imageObjs
    const fontStart = 3;
    const fontEnd = fontStart + fontNames.length - 1;
    let nextObj = fontEnd + 1;

    const pageObjNums = [];
    const pageInfo = this.pages.map((pg) => {
      const pageObj = nextObj++;
      const contentsObj = nextObj++;
      const imgObjs = pg.images.map(() => nextObj++);
      pageObjNums.push(pageObj);
      return { pageObj, contentsObj, imgObjs };
    });

    // PDF Header
    _pushStr('%PDF-1.4\n%\xE2\xE3\xCF\xD3\n');

    // Obj 1: Catalog
    _mark(1);
    _pushStr('1 0 obj\n<</Type /Catalog /Pages 2 0 R>>\nendobj\n');

    // Obj 2: Pages
    _mark(2);
    const kids = pageObjNums.map(n => `${n} 0 R`).join(' ');
    _pushStr(`2 0 obj\n<</Type /Pages /Kids [${kids}] /Count ${N}>>\nendobj\n`);

    // Font objects
    fontNames.forEach((fn, fi) => {
      const objN = fontStart + fi;
      _mark(objN);
      _pushStr(`${objN} 0 obj\n<</Type /Font /Subtype /Type1 /BaseFont /${fn} /Encoding /WinAnsiEncoding>>\nendobj\n`);
    });

    // Build font resource dict string
    const fontDict = fontNames.map((fn, fi) => `/${fn} ${fontStart + fi} 0 R`).join(' ');

    // Pages
    let globalImgIdx = 0;
    this.pages.forEach((pg, pi) => {
      const info = pageInfo[pi];

      // Build content stream
      let stream = pg.streams.join('');

      // Add image placement commands
      pg.images.forEach((img, ii) => {
        const imgName = `Im${pi}_${ii}`;
        stream += `q\n${this._n(img.w)} 0 0 ${this._n(img.h)} ${this._n(img.x)} ${this._n(img.y)} cm\n/${imgName} Do\nQ\n`;
      });

      // Image XObject dict
      const xobjEntries = pg.images.map((img, ii) => {
        return `/Im${pi}_${ii} ${info.imgObjs[ii]} 0 R`;
      }).join(' ');
      const xobjDict = pg.images.length > 0 ? ` /XObject <<${xobjEntries}>>` : '';

      // Page object
      _mark(info.pageObj);
      _pushStr(`${info.pageObj} 0 obj\n<</Type /Page /Parent 2 0 R /MediaBox [0 0 ${this._n(this.W)} ${this._n(this.H)}] /Contents ${info.contentsObj} 0 R /Resources <</Font <<${fontDict}>>${xobjDict}>>>>\nendobj\n`);

      // Contents stream
      const streamBytes = new TextEncoder().encode(stream);
      _mark(info.contentsObj);
      _pushStr(`${info.contentsObj} 0 obj\n<</Length ${streamBytes.length}>>\nstream\n`);
      _pushBytes(streamBytes);
      _pushStr('\nendstream\nendobj\n');

      // Image XObjects
      pg.images.forEach((img, ii) => {
        const pImg = processedImages[globalImgIdx++];
        if (!pImg) return;
        _mark(info.imgObjs[ii]);
        _pushStr(`${info.imgObjs[ii]} 0 obj\n<</Type /XObject /Subtype /Image /Width ${pImg.w} /Height ${pImg.h} /ColorSpace /DeviceRGB /BitsPerComponent 8 /Filter /DCTDecode /Length ${pImg.bytes.length}>>\nstream\n`);
        _pushBytes(pImg.bytes);
        _pushStr('\nendstream\nendobj\n');
      });
    });

    // Cross-reference
    const xrefPos = currentPos;
    const maxObj = nextObj - 1;
    _pushStr(`xref\n0 ${maxObj + 1}\n`);
    _pushStr('0000000000 65535 f \n');
    for (let n = 1; n <= maxObj; n++) {
      const off = offsets[n] !== undefined ? offsets[n] : 0;
      _pushStr(`${String(off).padStart(10, '0')} 00000 n \n`);
    }
    _pushStr(`trailer\n<</Size ${maxObj + 1} /Root 1 0 R>>\nstartxref\n${xrefPos}\n%%EOF\n`);

    // Assemble
    let total = 0;
    parts.forEach(p => total += p.length);
    const result = new Uint8Array(total);
    let cursor = 0;
    parts.forEach(p => { result.set(p, cursor); cursor += p.length; });
    return result;
  }
}

function downloadPDF(pdfBytes, filename) {
  const blob = new Blob([pdfBytes], { type: 'application/pdf' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
  showToast(`Saved: ${filename}`);
}

// ================================================================
// END JOURNAL PDF ENGINE
// ================================================================
async function boot() {
  await initDB();
  await loadMetrics();      // initializes to 50 if no stored values
  await loadBlocks();
  await loadHabits();
  await loadTodayLog();
  await loadMission();
  await loadTheme();
  await checkBackupReminder();
  // Recover any sessions that were "running" before page close
  state.blocks.filter(b=>b.status==='running').forEach(b=>{b.status='paused';dbPut('studyBlocks',b);});
  await renderDashboard();
  renderBlocks();
  renderHabits();
  setInterval(renderDashboard,30000);
}
boot();
</script>
  <script>
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('./sw.js').then(reg => {
    console.log('SW registered:', reg.scope);
  }).catch(err => {
    console.log('SW registration failed:', err);
  });
}
  </script>
</body>
</html>
